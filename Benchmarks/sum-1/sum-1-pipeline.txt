WARNING: You're attempting to print out a bitcode file.
This is inadvisable as it may cause display problems. If
you REALLY want to taste LLVM bitcode first-hand, you
can force output with the `-f' option.

Running pass: Annotation2MetadataPass on [module]
; *** IR Dump After Annotation2MetadataPass on [module] ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() #0 {
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  %3 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %1) #4
  call void @llvm.lifetime.start.p0(i64 4, ptr %2) #4
  %4 = load i32, ptr @size, align 4, !tbaa !11
  store i32 %4, ptr %2, align 4, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 4, ptr %3) #4
  store i32 0, ptr %3, align 4, !tbaa !11
  store i32 0, ptr %1, align 4, !tbaa !11
  br label %5

5:                                                ; preds = %32, %0
  %6 = load i32, ptr %1, align 4, !tbaa !11
  %7 = load i32, ptr %2, align 4, !tbaa !11
  %8 = icmp slt i32 %6, %7
  br i1 %8, label %9, label %35

9:                                                ; preds = %5
  %10 = load ptr, ptr @ima, align 8, !tbaa !9
  %11 = load i32, ptr %1, align 4, !tbaa !11
  %12 = sext i32 %11 to i64
  %13 = getelementptr inbounds i32, ptr %10, i64 %12
  %14 = load i32, ptr %13, align 4, !tbaa !11
  %15 = load ptr, ptr @imb, align 8, !tbaa !9
  %16 = load i32, ptr %1, align 4, !tbaa !11
  %17 = sext i32 %16 to i64
  %18 = getelementptr inbounds i32, ptr %15, i64 %17
  %19 = load i32, ptr %18, align 4, !tbaa !11
  %20 = add nsw i32 %14, %19
  %21 = load ptr, ptr @imr, align 8, !tbaa !9
  %22 = load i32, ptr %1, align 4, !tbaa !11
  %23 = sext i32 %22 to i64
  %24 = getelementptr inbounds i32, ptr %21, i64 %23
  store i32 %20, ptr %24, align 4, !tbaa !11
  %25 = load ptr, ptr @imr, align 8, !tbaa !9
  %26 = load i32, ptr %1, align 4, !tbaa !11
  %27 = sext i32 %26 to i64
  %28 = getelementptr inbounds i32, ptr %25, i64 %27
  %29 = load i32, ptr %28, align 4, !tbaa !11
  %30 = load i32, ptr %3, align 4, !tbaa !11
  %31 = add i32 %30, %29
  store i32 %31, ptr %3, align 4, !tbaa !11
  br label %32

32:                                               ; preds = %9
  %33 = load i32, ptr %1, align 4, !tbaa !11
  %34 = add nsw i32 %33, 1
  store i32 %34, ptr %1, align 4, !tbaa !11
  br label %5, !llvm.loop !16

35:                                               ; preds = %5
  %36 = load i32, ptr %3, align 4, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 4, ptr %3) #4
  call void @llvm.lifetime.end.p0(i64 4, ptr %2) #4
  call void @llvm.lifetime.end.p0(i64 4, ptr %1) #4
  ret i32 %36
}
Running pass: ForceFunctionAttrsPass on [module]
; *** IR Dump After ForceFunctionAttrsPass on [module] ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() #0 {
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  %3 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %1) #4
  call void @llvm.lifetime.start.p0(i64 4, ptr %2) #4
  %4 = load i32, ptr @size, align 4, !tbaa !11
  store i32 %4, ptr %2, align 4, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 4, ptr %3) #4
  store i32 0, ptr %3, align 4, !tbaa !11
  store i32 0, ptr %1, align 4, !tbaa !11
  br label %5

5:                                                ; preds = %32, %0
  %6 = load i32, ptr %1, align 4, !tbaa !11
  %7 = load i32, ptr %2, align 4, !tbaa !11
  %8 = icmp slt i32 %6, %7
  br i1 %8, label %9, label %35

9:                                                ; preds = %5
  %10 = load ptr, ptr @ima, align 8, !tbaa !9
  %11 = load i32, ptr %1, align 4, !tbaa !11
  %12 = sext i32 %11 to i64
  %13 = getelementptr inbounds i32, ptr %10, i64 %12
  %14 = load i32, ptr %13, align 4, !tbaa !11
  %15 = load ptr, ptr @imb, align 8, !tbaa !9
  %16 = load i32, ptr %1, align 4, !tbaa !11
  %17 = sext i32 %16 to i64
  %18 = getelementptr inbounds i32, ptr %15, i64 %17
  %19 = load i32, ptr %18, align 4, !tbaa !11
  %20 = add nsw i32 %14, %19
  %21 = load ptr, ptr @imr, align 8, !tbaa !9
  %22 = load i32, ptr %1, align 4, !tbaa !11
  %23 = sext i32 %22 to i64
  %24 = getelementptr inbounds i32, ptr %21, i64 %23
  store i32 %20, ptr %24, align 4, !tbaa !11
  %25 = load ptr, ptr @imr, align 8, !tbaa !9
  %26 = load i32, ptr %1, align 4, !tbaa !11
  %27 = sext i32 %26 to i64
  %28 = getelementptr inbounds i32, ptr %25, i64 %27
  %29 = load i32, ptr %28, align 4, !tbaa !11
  %30 = load i32, ptr %3, align 4, !tbaa !11
  %31 = add i32 %30, %29
  store i32 %31, ptr %3, align 4, !tbaa !11
  br label %32

32:                                               ; preds = %9
  %33 = load i32, ptr %1, align 4, !tbaa !11
  %34 = add nsw i32 %33, 1
  store i32 %34, ptr %1, align 4, !tbaa !11
  br label %5, !llvm.loop !16

35:                                               ; preds = %5
  %36 = load i32, ptr %3, align 4, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 4, ptr %3) #4
  call void @llvm.lifetime.end.p0(i64 4, ptr %2) #4
  call void @llvm.lifetime.end.p0(i64 4, ptr %1) #4
  ret i32 %36
}
Running pass: InferFunctionAttrsPass on [module]
Running analysis: InnerAnalysisManagerProxy<AnalysisManager<Function>, Module> on [module]
Running analysis: TargetLibraryAnalysis on llvm.lifetime.start.p0
Running analysis: TargetLibraryAnalysis on llvm.lifetime.end.p0
Running analysis: TargetLibraryAnalysis on calloc
Running analysis: TargetLibraryAnalysis on free
Invalidating analysis: InnerAnalysisManagerProxy<AnalysisManager<Function>, Module> on [module]
; *** IR Dump After InferFunctionAttrsPass on [module] ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() #0 {
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  %3 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %1) #4
  call void @llvm.lifetime.start.p0(i64 4, ptr %2) #4
  %4 = load i32, ptr @size, align 4, !tbaa !11
  store i32 %4, ptr %2, align 4, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 4, ptr %3) #4
  store i32 0, ptr %3, align 4, !tbaa !11
  store i32 0, ptr %1, align 4, !tbaa !11
  br label %5

5:                                                ; preds = %32, %0
  %6 = load i32, ptr %1, align 4, !tbaa !11
  %7 = load i32, ptr %2, align 4, !tbaa !11
  %8 = icmp slt i32 %6, %7
  br i1 %8, label %9, label %35

9:                                                ; preds = %5
  %10 = load ptr, ptr @ima, align 8, !tbaa !9
  %11 = load i32, ptr %1, align 4, !tbaa !11
  %12 = sext i32 %11 to i64
  %13 = getelementptr inbounds i32, ptr %10, i64 %12
  %14 = load i32, ptr %13, align 4, !tbaa !11
  %15 = load ptr, ptr @imb, align 8, !tbaa !9
  %16 = load i32, ptr %1, align 4, !tbaa !11
  %17 = sext i32 %16 to i64
  %18 = getelementptr inbounds i32, ptr %15, i64 %17
  %19 = load i32, ptr %18, align 4, !tbaa !11
  %20 = add nsw i32 %14, %19
  %21 = load ptr, ptr @imr, align 8, !tbaa !9
  %22 = load i32, ptr %1, align 4, !tbaa !11
  %23 = sext i32 %22 to i64
  %24 = getelementptr inbounds i32, ptr %21, i64 %23
  store i32 %20, ptr %24, align 4, !tbaa !11
  %25 = load ptr, ptr @imr, align 8, !tbaa !9
  %26 = load i32, ptr %1, align 4, !tbaa !11
  %27 = sext i32 %26 to i64
  %28 = getelementptr inbounds i32, ptr %25, i64 %27
  %29 = load i32, ptr %28, align 4, !tbaa !11
  %30 = load i32, ptr %3, align 4, !tbaa !11
  %31 = add i32 %30, %29
  store i32 %31, ptr %3, align 4, !tbaa !11
  br label %32

32:                                               ; preds = %9
  %33 = load i32, ptr %1, align 4, !tbaa !11
  %34 = add nsw i32 %33, 1
  store i32 %34, ptr %1, align 4, !tbaa !11
  br label %5, !llvm.loop !16

35:                                               ; preds = %5
  %36 = load i32, ptr %3, align 4, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 4, ptr %3) #4
  call void @llvm.lifetime.end.p0(i64 4, ptr %2) #4
  call void @llvm.lifetime.end.p0(i64 4, ptr %1) #4
  ret i32 %36
}
Running pass: CoroEarlyPass on [module]
; *** IR Dump After CoroEarlyPass on [module] ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() #0 {
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  %3 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %1) #4
  call void @llvm.lifetime.start.p0(i64 4, ptr %2) #4
  %4 = load i32, ptr @size, align 4, !tbaa !11
  store i32 %4, ptr %2, align 4, !tbaa !11
  call void @llvm.lifetime.start.p0(i64 4, ptr %3) #4
  store i32 0, ptr %3, align 4, !tbaa !11
  store i32 0, ptr %1, align 4, !tbaa !11
  br label %5

5:                                                ; preds = %32, %0
  %6 = load i32, ptr %1, align 4, !tbaa !11
  %7 = load i32, ptr %2, align 4, !tbaa !11
  %8 = icmp slt i32 %6, %7
  br i1 %8, label %9, label %35

9:                                                ; preds = %5
  %10 = load ptr, ptr @ima, align 8, !tbaa !9
  %11 = load i32, ptr %1, align 4, !tbaa !11
  %12 = sext i32 %11 to i64
  %13 = getelementptr inbounds i32, ptr %10, i64 %12
  %14 = load i32, ptr %13, align 4, !tbaa !11
  %15 = load ptr, ptr @imb, align 8, !tbaa !9
  %16 = load i32, ptr %1, align 4, !tbaa !11
  %17 = sext i32 %16 to i64
  %18 = getelementptr inbounds i32, ptr %15, i64 %17
  %19 = load i32, ptr %18, align 4, !tbaa !11
  %20 = add nsw i32 %14, %19
  %21 = load ptr, ptr @imr, align 8, !tbaa !9
  %22 = load i32, ptr %1, align 4, !tbaa !11
  %23 = sext i32 %22 to i64
  %24 = getelementptr inbounds i32, ptr %21, i64 %23
  store i32 %20, ptr %24, align 4, !tbaa !11
  %25 = load ptr, ptr @imr, align 8, !tbaa !9
  %26 = load i32, ptr %1, align 4, !tbaa !11
  %27 = sext i32 %26 to i64
  %28 = getelementptr inbounds i32, ptr %25, i64 %27
  %29 = load i32, ptr %28, align 4, !tbaa !11
  %30 = load i32, ptr %3, align 4, !tbaa !11
  %31 = add i32 %30, %29
  store i32 %31, ptr %3, align 4, !tbaa !11
  br label %32

32:                                               ; preds = %9
  %33 = load i32, ptr %1, align 4, !tbaa !11
  %34 = add nsw i32 %33, 1
  store i32 %34, ptr %1, align 4, !tbaa !11
  br label %5, !llvm.loop !16

35:                                               ; preds = %5
  %36 = load i32, ptr %3, align 4, !tbaa !11
  call void @llvm.lifetime.end.p0(i64 4, ptr %3) #4
  call void @llvm.lifetime.end.p0(i64 4, ptr %2) #4
  call void @llvm.lifetime.end.p0(i64 4, ptr %1) #4
  ret i32 %36
}
Running analysis: InnerAnalysisManagerProxy<AnalysisManager<Function>, Module> on [module]
Running pass: EntryExitInstrumenterPass on Initrand (2 instructions)
Running pass: LowerExpectIntrinsicPass on Initrand (2 instructions)
Running pass: SimplifyCFGPass on Initrand (2 instructions)
Running analysis: TargetIRAnalysis on Initrand
Running analysis: AssumptionAnalysis on Initrand
Running pass: SROAPass on Initrand (2 instructions)
Running analysis: DominatorTreeAnalysis on Initrand
Running pass: EarlyCSEPass on Initrand (2 instructions)
Running analysis: TargetLibraryAnalysis on Initrand
Running pass: CallSiteSplittingPass on Initrand (2 instructions)
Invalidating analysis: DominatorTreeAnalysis on Initrand
Running pass: EntryExitInstrumenterPass on Rand (8 instructions)
Running pass: LowerExpectIntrinsicPass on Rand (8 instructions)
Running pass: SimplifyCFGPass on Rand (8 instructions)
Running analysis: TargetIRAnalysis on Rand
Running analysis: AssumptionAnalysis on Rand
Running pass: SROAPass on Rand (8 instructions)
Running analysis: DominatorTreeAnalysis on Rand
Running pass: EarlyCSEPass on Rand (8 instructions)
Running analysis: TargetLibraryAnalysis on Rand
Running pass: CallSiteSplittingPass on Rand (7 instructions)
Invalidating analysis: DominatorTreeAnalysis on Rand
Running pass: EntryExitInstrumenterPass on InitArray (36 instructions)
Running pass: LowerExpectIntrinsicPass on InitArray (36 instructions)
Running pass: SimplifyCFGPass on InitArray (36 instructions)
Running analysis: TargetIRAnalysis on InitArray
Running analysis: AssumptionAnalysis on InitArray
Running pass: SROAPass on InitArray (35 instructions)
Running analysis: DominatorTreeAnalysis on InitArray
Running pass: EarlyCSEPass on InitArray (16 instructions)
Running analysis: TargetLibraryAnalysis on InitArray
Running pass: CallSiteSplittingPass on InitArray (16 instructions)
Invalidating analysis: DominatorTreeAnalysis on InitArray
Running pass: EntryExitInstrumenterPass on init (47 instructions)
Running pass: LowerExpectIntrinsicPass on init (47 instructions)
Running pass: SimplifyCFGPass on init (47 instructions)
Running analysis: TargetIRAnalysis on init
Running analysis: AssumptionAnalysis on init
Running pass: SROAPass on init (47 instructions)
Running analysis: DominatorTreeAnalysis on init
Running pass: EarlyCSEPass on init (36 instructions)
Running analysis: TargetLibraryAnalysis on init
Running pass: CallSiteSplittingPass on init (31 instructions)
Invalidating analysis: DominatorTreeAnalysis on init
Running pass: EntryExitInstrumenterPass on deinit (7 instructions)
Running pass: LowerExpectIntrinsicPass on deinit (7 instructions)
Running pass: SimplifyCFGPass on deinit (7 instructions)
Running analysis: TargetIRAnalysis on deinit
Running analysis: AssumptionAnalysis on deinit
Running pass: SROAPass on deinit (7 instructions)
Running analysis: DominatorTreeAnalysis on deinit
Running pass: EarlyCSEPass on deinit (7 instructions)
Running analysis: TargetLibraryAnalysis on deinit
Running pass: CallSiteSplittingPass on deinit (7 instructions)
Invalidating analysis: DominatorTreeAnalysis on deinit
Running pass: EntryExitInstrumenterPass on sum_1 (49 instructions)
; *** IR Dump After EntryExitInstrumenterPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() #0 {
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  %3 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %1) #4
  call void @llvm.lifetime.start.p0(i64 4, ptr %2) #4
  %4 = load i32, ptr @size, align 4, !tbaa !9
  store i32 %4, ptr %2, align 4, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 4, ptr %3) #4
  store i32 0, ptr %3, align 4, !tbaa !9
  store i32 0, ptr %1, align 4, !tbaa !9
  br label %5

5:                                                ; preds = %32, %0
  %6 = load i32, ptr %1, align 4, !tbaa !9
  %7 = load i32, ptr %2, align 4, !tbaa !9
  %8 = icmp slt i32 %6, %7
  br i1 %8, label %9, label %35

9:                                                ; preds = %5
  %10 = load ptr, ptr @ima, align 8, !tbaa !14
  %11 = load i32, ptr %1, align 4, !tbaa !9
  %12 = sext i32 %11 to i64
  %13 = getelementptr inbounds i32, ptr %10, i64 %12
  %14 = load i32, ptr %13, align 4, !tbaa !9
  %15 = load ptr, ptr @imb, align 8, !tbaa !14
  %16 = load i32, ptr %1, align 4, !tbaa !9
  %17 = sext i32 %16 to i64
  %18 = getelementptr inbounds i32, ptr %15, i64 %17
  %19 = load i32, ptr %18, align 4, !tbaa !9
  %20 = add nsw i32 %14, %19
  %21 = load ptr, ptr @imr, align 8, !tbaa !14
  %22 = load i32, ptr %1, align 4, !tbaa !9
  %23 = sext i32 %22 to i64
  %24 = getelementptr inbounds i32, ptr %21, i64 %23
  store i32 %20, ptr %24, align 4, !tbaa !9
  %25 = load ptr, ptr @imr, align 8, !tbaa !14
  %26 = load i32, ptr %1, align 4, !tbaa !9
  %27 = sext i32 %26 to i64
  %28 = getelementptr inbounds i32, ptr %25, i64 %27
  %29 = load i32, ptr %28, align 4, !tbaa !9
  %30 = load i32, ptr %3, align 4, !tbaa !9
  %31 = add i32 %30, %29
  store i32 %31, ptr %3, align 4, !tbaa !9
  br label %32

32:                                               ; preds = %9
  %33 = load i32, ptr %1, align 4, !tbaa !9
  %34 = add nsw i32 %33, 1
  store i32 %34, ptr %1, align 4, !tbaa !9
  br label %5, !llvm.loop !16

35:                                               ; preds = %5
  %36 = load i32, ptr %3, align 4, !tbaa !9
  call void @llvm.lifetime.end.p0(i64 4, ptr %3) #4
  call void @llvm.lifetime.end.p0(i64 4, ptr %2) #4
  call void @llvm.lifetime.end.p0(i64 4, ptr %1) #4
  ret i32 %36
}
Running pass: LowerExpectIntrinsicPass on sum_1 (49 instructions)
; *** IR Dump After LowerExpectIntrinsicPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() #0 {
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  %3 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %1) #4
  call void @llvm.lifetime.start.p0(i64 4, ptr %2) #4
  %4 = load i32, ptr @size, align 4, !tbaa !9
  store i32 %4, ptr %2, align 4, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 4, ptr %3) #4
  store i32 0, ptr %3, align 4, !tbaa !9
  store i32 0, ptr %1, align 4, !tbaa !9
  br label %5

5:                                                ; preds = %32, %0
  %6 = load i32, ptr %1, align 4, !tbaa !9
  %7 = load i32, ptr %2, align 4, !tbaa !9
  %8 = icmp slt i32 %6, %7
  br i1 %8, label %9, label %35

9:                                                ; preds = %5
  %10 = load ptr, ptr @ima, align 8, !tbaa !14
  %11 = load i32, ptr %1, align 4, !tbaa !9
  %12 = sext i32 %11 to i64
  %13 = getelementptr inbounds i32, ptr %10, i64 %12
  %14 = load i32, ptr %13, align 4, !tbaa !9
  %15 = load ptr, ptr @imb, align 8, !tbaa !14
  %16 = load i32, ptr %1, align 4, !tbaa !9
  %17 = sext i32 %16 to i64
  %18 = getelementptr inbounds i32, ptr %15, i64 %17
  %19 = load i32, ptr %18, align 4, !tbaa !9
  %20 = add nsw i32 %14, %19
  %21 = load ptr, ptr @imr, align 8, !tbaa !14
  %22 = load i32, ptr %1, align 4, !tbaa !9
  %23 = sext i32 %22 to i64
  %24 = getelementptr inbounds i32, ptr %21, i64 %23
  store i32 %20, ptr %24, align 4, !tbaa !9
  %25 = load ptr, ptr @imr, align 8, !tbaa !14
  %26 = load i32, ptr %1, align 4, !tbaa !9
  %27 = sext i32 %26 to i64
  %28 = getelementptr inbounds i32, ptr %25, i64 %27
  %29 = load i32, ptr %28, align 4, !tbaa !9
  %30 = load i32, ptr %3, align 4, !tbaa !9
  %31 = add i32 %30, %29
  store i32 %31, ptr %3, align 4, !tbaa !9
  br label %32

32:                                               ; preds = %9
  %33 = load i32, ptr %1, align 4, !tbaa !9
  %34 = add nsw i32 %33, 1
  store i32 %34, ptr %1, align 4, !tbaa !9
  br label %5, !llvm.loop !16

35:                                               ; preds = %5
  %36 = load i32, ptr %3, align 4, !tbaa !9
  call void @llvm.lifetime.end.p0(i64 4, ptr %3) #4
  call void @llvm.lifetime.end.p0(i64 4, ptr %2) #4
  call void @llvm.lifetime.end.p0(i64 4, ptr %1) #4
  ret i32 %36
}
Running pass: SimplifyCFGPass on sum_1 (49 instructions)
Running analysis: TargetIRAnalysis on sum_1
Running analysis: AssumptionAnalysis on sum_1
; *** IR Dump After SimplifyCFGPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() #0 {
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  %3 = alloca i32, align 4
  call void @llvm.lifetime.start.p0(i64 4, ptr %1) #4
  call void @llvm.lifetime.start.p0(i64 4, ptr %2) #4
  %4 = load i32, ptr @size, align 4, !tbaa !9
  store i32 %4, ptr %2, align 4, !tbaa !9
  call void @llvm.lifetime.start.p0(i64 4, ptr %3) #4
  store i32 0, ptr %3, align 4, !tbaa !9
  store i32 0, ptr %1, align 4, !tbaa !9
  br label %5

5:                                                ; preds = %9, %0
  %6 = load i32, ptr %1, align 4, !tbaa !9
  %7 = load i32, ptr %2, align 4, !tbaa !9
  %8 = icmp slt i32 %6, %7
  br i1 %8, label %9, label %34

9:                                                ; preds = %5
  %10 = load ptr, ptr @ima, align 8, !tbaa !14
  %11 = load i32, ptr %1, align 4, !tbaa !9
  %12 = sext i32 %11 to i64
  %13 = getelementptr inbounds i32, ptr %10, i64 %12
  %14 = load i32, ptr %13, align 4, !tbaa !9
  %15 = load ptr, ptr @imb, align 8, !tbaa !14
  %16 = load i32, ptr %1, align 4, !tbaa !9
  %17 = sext i32 %16 to i64
  %18 = getelementptr inbounds i32, ptr %15, i64 %17
  %19 = load i32, ptr %18, align 4, !tbaa !9
  %20 = add nsw i32 %14, %19
  %21 = load ptr, ptr @imr, align 8, !tbaa !14
  %22 = load i32, ptr %1, align 4, !tbaa !9
  %23 = sext i32 %22 to i64
  %24 = getelementptr inbounds i32, ptr %21, i64 %23
  store i32 %20, ptr %24, align 4, !tbaa !9
  %25 = load ptr, ptr @imr, align 8, !tbaa !14
  %26 = load i32, ptr %1, align 4, !tbaa !9
  %27 = sext i32 %26 to i64
  %28 = getelementptr inbounds i32, ptr %25, i64 %27
  %29 = load i32, ptr %28, align 4, !tbaa !9
  %30 = load i32, ptr %3, align 4, !tbaa !9
  %31 = add i32 %30, %29
  store i32 %31, ptr %3, align 4, !tbaa !9
  %32 = load i32, ptr %1, align 4, !tbaa !9
  %33 = add nsw i32 %32, 1
  store i32 %33, ptr %1, align 4, !tbaa !9
  br label %5, !llvm.loop !16

34:                                               ; preds = %5
  %35 = load i32, ptr %3, align 4, !tbaa !9
  call void @llvm.lifetime.end.p0(i64 4, ptr %3) #4
  call void @llvm.lifetime.end.p0(i64 4, ptr %2) #4
  call void @llvm.lifetime.end.p0(i64 4, ptr %1) #4
  ret i32 %35
}
Running pass: SROAPass on sum_1 (48 instructions)
Running analysis: DominatorTreeAnalysis on sum_1
; *** IR Dump After SROAPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() #0 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %22, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %21, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %23

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !14
  %6 = sext i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = load ptr, ptr @imb, align 8, !tbaa !14
  %10 = sext i32 %.09 to i64
  %11 = getelementptr inbounds i32, ptr %9, i64 %10
  %12 = load i32, ptr %11, align 4, !tbaa !9
  %13 = add nsw i32 %8, %12
  %14 = load ptr, ptr @imr, align 8, !tbaa !14
  %15 = sext i32 %.09 to i64
  %16 = getelementptr inbounds i32, ptr %14, i64 %15
  store i32 %13, ptr %16, align 4, !tbaa !9
  %17 = load ptr, ptr @imr, align 8, !tbaa !14
  %18 = sext i32 %.09 to i64
  %19 = getelementptr inbounds i32, ptr %17, i64 %18
  %20 = load i32, ptr %19, align 4, !tbaa !9
  %21 = add i32 %.0, %20
  %22 = add nsw i32 %.09, 1
  br label %2, !llvm.loop !16

23:                                               ; preds = %2
  ret i32 %.0
}
Running pass: EarlyCSEPass on sum_1 (27 instructions)
Running analysis: TargetLibraryAnalysis on sum_1
; *** IR Dump After EarlyCSEPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() #0 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %19, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %18, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %20

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !14
  %6 = sext i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = load ptr, ptr @imb, align 8, !tbaa !14
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !9
  %12 = add nsw i32 %8, %11
  %13 = load ptr, ptr @imr, align 8, !tbaa !14
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !9
  %15 = load ptr, ptr @imr, align 8, !tbaa !14
  %16 = getelementptr inbounds i32, ptr %15, i64 %6
  %17 = load i32, ptr %16, align 4, !tbaa !9
  %18 = add i32 %.0, %17
  %19 = add nsw i32 %.09, 1
  br label %2, !llvm.loop !16

20:                                               ; preds = %2
  ret i32 %.0
}
Running pass: CallSiteSplittingPass on sum_1 (24 instructions)
; *** IR Dump After CallSiteSplittingPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() #0 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %19, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %18, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %20

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !14
  %6 = sext i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = load ptr, ptr @imb, align 8, !tbaa !14
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !9
  %12 = add nsw i32 %8, %11
  %13 = load ptr, ptr @imr, align 8, !tbaa !14
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !9
  %15 = load ptr, ptr @imr, align 8, !tbaa !14
  %16 = getelementptr inbounds i32, ptr %15, i64 %6
  %17 = load i32, ptr %16, align 4, !tbaa !9
  %18 = add i32 %.0, %17
  %19 = add nsw i32 %.09, 1
  br label %2, !llvm.loop !16

20:                                               ; preds = %2
  ret i32 %.0
}
Invalidating analysis: DominatorTreeAnalysis on sum_1
Running pass: OpenMPOptPass on [module]
; *** IR Dump After OpenMPOptPass on [module] ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() #0 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %19, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %18, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %20

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !14
  %6 = sext i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = load ptr, ptr @imb, align 8, !tbaa !14
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !9
  %12 = add nsw i32 %8, %11
  %13 = load ptr, ptr @imr, align 8, !tbaa !14
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !9
  %15 = load ptr, ptr @imr, align 8, !tbaa !14
  %16 = getelementptr inbounds i32, ptr %15, i64 %6
  %17 = load i32, ptr %16, align 4, !tbaa !9
  %18 = add i32 %.0, %17
  %19 = add nsw i32 %.09, 1
  br label %2, !llvm.loop !16

20:                                               ; preds = %2
  ret i32 %.0
}
Running pass: IPSCCPPass on [module]
Running analysis: DominatorTreeAnalysis on Initrand
Running analysis: DominatorTreeAnalysis on Rand
Running analysis: DominatorTreeAnalysis on InitArray
Running analysis: DominatorTreeAnalysis on init
Running analysis: DominatorTreeAnalysis on deinit
Running analysis: DominatorTreeAnalysis on sum_1
; *** IR Dump After IPSCCPPass on [module] ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() #0 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %19, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %18, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %20

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !14
  %6 = sext i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = load ptr, ptr @imb, align 8, !tbaa !14
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !9
  %12 = add nsw i32 %8, %11
  %13 = load ptr, ptr @imr, align 8, !tbaa !14
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !9
  %15 = load ptr, ptr @imr, align 8, !tbaa !14
  %16 = getelementptr inbounds i32, ptr %15, i64 %6
  %17 = load i32, ptr %16, align 4, !tbaa !9
  %18 = add i32 %.0, %17
  %19 = add nsw i32 %.09, 1
  br label %2, !llvm.loop !16

20:                                               ; preds = %2
  ret i32 %.0
}
Running pass: CalledValuePropagationPass on [module]
; *** IR Dump After CalledValuePropagationPass on [module] ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() #0 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %19, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %18, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %20

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !14
  %6 = sext i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = load ptr, ptr @imb, align 8, !tbaa !14
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !9
  %12 = add nsw i32 %8, %11
  %13 = load ptr, ptr @imr, align 8, !tbaa !14
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !9
  %15 = load ptr, ptr @imr, align 8, !tbaa !14
  %16 = getelementptr inbounds i32, ptr %15, i64 %6
  %17 = load i32, ptr %16, align 4, !tbaa !9
  %18 = add i32 %.0, %17
  %19 = add nsw i32 %.09, 1
  br label %2, !llvm.loop !16

20:                                               ; preds = %2
  ret i32 %.0
}
Running pass: GlobalOptPass on [module]
Running analysis: TargetLibraryAnalysis on calloc
; *** IR Dump After GlobalOptPass on [module] ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #0 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %19, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %18, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %20

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !14
  %6 = sext i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = load ptr, ptr @imb, align 8, !tbaa !14
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !9
  %12 = add nsw i32 %8, %11
  %13 = load ptr, ptr @imr, align 8, !tbaa !14
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !9
  %15 = load ptr, ptr @imr, align 8, !tbaa !14
  %16 = getelementptr inbounds i32, ptr %15, i64 %6
  %17 = load i32, ptr %16, align 4, !tbaa !9
  %18 = add i32 %.0, %17
  %19 = add nsw i32 %.09, 1
  br label %2, !llvm.loop !16

20:                                               ; preds = %2
  ret i32 %.0
}
Running pass: PromotePass on Initrand (2 instructions)
Running pass: InstCombinePass on Initrand (2 instructions)
Running analysis: OptimizationRemarkEmitterAnalysis on Initrand
Running analysis: AAManager on Initrand
Running analysis: BasicAA on Initrand
Running analysis: ScopedNoAliasAA on Initrand
Running analysis: TypeBasedAA on Initrand
Running analysis: OuterAnalysisManagerProxy<AnalysisManager<Module>, Function> on Initrand
Running pass: SimplifyCFGPass on Initrand (2 instructions)
Invalidating analysis: DominatorTreeAnalysis on Initrand
Invalidating analysis: BasicAA on Initrand
Invalidating analysis: AAManager on Initrand
Running pass: PromotePass on Rand (7 instructions)
Running pass: InstCombinePass on Rand (7 instructions)
Running analysis: OptimizationRemarkEmitterAnalysis on Rand
Running analysis: AAManager on Rand
Running analysis: BasicAA on Rand
Running analysis: ScopedNoAliasAA on Rand
Running analysis: TypeBasedAA on Rand
Running analysis: OuterAnalysisManagerProxy<AnalysisManager<Module>, Function> on Rand
Running pass: SimplifyCFGPass on Rand (7 instructions)
Invalidating analysis: DominatorTreeAnalysis on Rand
Invalidating analysis: BasicAA on Rand
Invalidating analysis: AAManager on Rand
Running pass: PromotePass on InitArray (16 instructions)
Running pass: InstCombinePass on InitArray (16 instructions)
Running analysis: OptimizationRemarkEmitterAnalysis on InitArray
Running analysis: AAManager on InitArray
Running analysis: BasicAA on InitArray
Running analysis: ScopedNoAliasAA on InitArray
Running analysis: TypeBasedAA on InitArray
Running analysis: OuterAnalysisManagerProxy<AnalysisManager<Module>, Function> on InitArray
Running pass: SimplifyCFGPass on InitArray (15 instructions)
Invalidating analysis: DominatorTreeAnalysis on InitArray
Invalidating analysis: BasicAA on InitArray
Invalidating analysis: AAManager on InitArray
Running pass: PromotePass on init (31 instructions)
Running pass: InstCombinePass on init (31 instructions)
Running analysis: OptimizationRemarkEmitterAnalysis on init
Running analysis: AAManager on init
Running analysis: BasicAA on init
Running analysis: ScopedNoAliasAA on init
Running analysis: TypeBasedAA on init
Running analysis: OuterAnalysisManagerProxy<AnalysisManager<Module>, Function> on init
Running pass: SimplifyCFGPass on init (31 instructions)
Invalidating analysis: DominatorTreeAnalysis on init
Invalidating analysis: BasicAA on init
Invalidating analysis: AAManager on init
Running pass: PromotePass on deinit (7 instructions)
Running pass: InstCombinePass on deinit (7 instructions)
Running analysis: OptimizationRemarkEmitterAnalysis on deinit
Running analysis: AAManager on deinit
Running analysis: BasicAA on deinit
Running analysis: ScopedNoAliasAA on deinit
Running analysis: TypeBasedAA on deinit
Running analysis: OuterAnalysisManagerProxy<AnalysisManager<Module>, Function> on deinit
Running pass: SimplifyCFGPass on deinit (7 instructions)
Invalidating analysis: DominatorTreeAnalysis on deinit
Invalidating analysis: BasicAA on deinit
Invalidating analysis: AAManager on deinit
Running pass: PromotePass on sum_1 (24 instructions)
; *** IR Dump After PromotePass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #0 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %19, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %18, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %20

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !14
  %6 = sext i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = load ptr, ptr @imb, align 8, !tbaa !14
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !9
  %12 = add nsw i32 %8, %11
  %13 = load ptr, ptr @imr, align 8, !tbaa !14
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !9
  %15 = load ptr, ptr @imr, align 8, !tbaa !14
  %16 = getelementptr inbounds i32, ptr %15, i64 %6
  %17 = load i32, ptr %16, align 4, !tbaa !9
  %18 = add i32 %.0, %17
  %19 = add nsw i32 %.09, 1
  br label %2, !llvm.loop !16

20:                                               ; preds = %2
  ret i32 %.0
}
Running pass: InstCombinePass on sum_1 (24 instructions)
Running analysis: OptimizationRemarkEmitterAnalysis on sum_1
Running analysis: AAManager on sum_1
Running analysis: BasicAA on sum_1
Running analysis: ScopedNoAliasAA on sum_1
Running analysis: TypeBasedAA on sum_1
Running analysis: OuterAnalysisManagerProxy<AnalysisManager<Module>, Function> on sum_1
; *** IR Dump After InstCombinePass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #0 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %16, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %15, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %17

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !14
  %6 = zext nneg i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = load ptr, ptr @imb, align 8, !tbaa !14
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !9
  %12 = add nsw i32 %8, %11
  %13 = load ptr, ptr @imr, align 8, !tbaa !14
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !9
  %15 = add i32 %.0, %12
  %16 = add nuw nsw i32 %.09, 1
  br label %2, !llvm.loop !16

17:                                               ; preds = %2
  ret i32 %.0
}
Running pass: SimplifyCFGPass on sum_1 (21 instructions)
; *** IR Dump After SimplifyCFGPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #0 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %16, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %15, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %17

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !14
  %6 = zext nneg i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = load ptr, ptr @imb, align 8, !tbaa !14
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !9
  %12 = add nsw i32 %8, %11
  %13 = load ptr, ptr @imr, align 8, !tbaa !14
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !9
  %15 = add i32 %.0, %12
  %16 = add nuw nsw i32 %.09, 1
  br label %2, !llvm.loop !16

17:                                               ; preds = %2
  ret i32 %.0
}
Invalidating analysis: DominatorTreeAnalysis on sum_1
Invalidating analysis: BasicAA on sum_1
Invalidating analysis: AAManager on sum_1
Running pass: AlwaysInlinerPass on [module]
Running analysis: ProfileSummaryAnalysis on [module]
; *** IR Dump After AlwaysInlinerPass on [module] ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #0 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %16, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %15, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %17

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !14
  %6 = zext nneg i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = load ptr, ptr @imb, align 8, !tbaa !14
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !9
  %12 = add nsw i32 %8, %11
  %13 = load ptr, ptr @imr, align 8, !tbaa !14
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !9
  %15 = add i32 %.0, %12
  %16 = add nuw nsw i32 %.09, 1
  br label %2, !llvm.loop !16

17:                                               ; preds = %2
  ret i32 %.0
}
Running pass: ModuleInlinerWrapperPass on [module]
Running analysis: InlineAdvisorAnalysis on [module]
Running pass: RequireAnalysisPass<GlobalsAA, Module> on [module]
Running analysis: GlobalsAA on [module]
Running analysis: CallGraphAnalysis on [module]
; *** IR Dump After RequireAnalysisPass<GlobalsAA, Module> on [module] ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #0 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %16, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %15, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %17

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !14
  %6 = zext nneg i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = load ptr, ptr @imb, align 8, !tbaa !14
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !9
  %12 = add nsw i32 %8, %11
  %13 = load ptr, ptr @imr, align 8, !tbaa !14
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !9
  %15 = add i32 %.0, %12
  %16 = add nuw nsw i32 %.09, 1
  br label %2, !llvm.loop !16

17:                                               ; preds = %2
  ret i32 %.0
}
Running pass: InvalidateAnalysisPass<AAManager> on Initrand (2 instructions)
Running pass: InvalidateAnalysisPass<AAManager> on Rand (7 instructions)
Running pass: InvalidateAnalysisPass<AAManager> on InitArray (15 instructions)
Running pass: InvalidateAnalysisPass<AAManager> on init (30 instructions)
Running pass: InvalidateAnalysisPass<AAManager> on deinit (7 instructions)
Running pass: InvalidateAnalysisPass<AAManager> on sum_1 (21 instructions)
; *** IR Dump After InvalidateAnalysisPass<AAManager> on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #0 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %16, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %15, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %17

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !14
  %6 = zext nneg i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = load ptr, ptr @imb, align 8, !tbaa !14
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !9
  %12 = add nsw i32 %8, %11
  %13 = load ptr, ptr @imr, align 8, !tbaa !14
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !9
  %15 = add i32 %.0, %12
  %16 = add nuw nsw i32 %.09, 1
  br label %2, !llvm.loop !16

17:                                               ; preds = %2
  ret i32 %.0
}
Running pass: RequireAnalysisPass<ProfileSummaryAnalysis, Module> on [module]
; *** IR Dump After RequireAnalysisPass<ProfileSummaryAnalysis, Module> on [module] ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #0 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %16, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %15, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %17

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !14
  %6 = zext nneg i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = load ptr, ptr @imb, align 8, !tbaa !14
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !9
  %12 = add nsw i32 %8, %11
  %13 = load ptr, ptr @imr, align 8, !tbaa !14
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !9
  %15 = add i32 %.0, %12
  %16 = add nuw nsw i32 %.09, 1
  br label %2, !llvm.loop !16

17:                                               ; preds = %2
  ret i32 %.0
}
Running analysis: InnerAnalysisManagerProxy<AnalysisManager<LazyCallGraph::SCC, LazyCallGraph&>, Module> on [module]
Running analysis: LazyCallGraphAnalysis on [module]
Running analysis: FunctionAnalysisManagerCGSCCProxy on (Initrand)
Running analysis: OuterAnalysisManagerProxy<AnalysisManager<Module>, LazyCallGraph::SCC, LazyCallGraph&> on (Initrand)
Running pass: DevirtSCCRepeatedPass on (Initrand) (1 node)
Running pass: InlinerPass on (Initrand) (1 node)
Running pass: PostOrderFunctionAttrsPass on (Initrand) (1 node)
Running pass: ArgumentPromotionPass on (Initrand) (1 node)
Running pass: OpenMPOptCGSCCPass on (Initrand) (1 node)
Running pass: SROAPass on Initrand (2 instructions)
Running analysis: DominatorTreeAnalysis on Initrand
Running pass: EarlyCSEPass on Initrand (2 instructions)
Running analysis: MemorySSAAnalysis on Initrand
Running analysis: AAManager on Initrand
Running analysis: BasicAA on Initrand
Running pass: SpeculativeExecutionPass on Initrand (2 instructions)
Running pass: JumpThreadingPass on Initrand (2 instructions)
Running analysis: LazyValueAnalysis on Initrand
Running pass: CorrelatedValuePropagationPass on Initrand (2 instructions)
Invalidating analysis: LazyValueAnalysis on Initrand
Running pass: SimplifyCFGPass on Initrand (2 instructions)
Running pass: InstCombinePass on Initrand (2 instructions)
Running pass: AggressiveInstCombinePass on Initrand (2 instructions)
Running pass: LibCallsShrinkWrapPass on Initrand (2 instructions)
Running pass: TailCallElimPass on Initrand (2 instructions)
Running pass: SimplifyCFGPass on Initrand (2 instructions)
Running pass: ReassociatePass on Initrand (2 instructions)
Running pass: ConstraintEliminationPass on Initrand (2 instructions)
Running analysis: LoopAnalysis on Initrand
Running analysis: ScalarEvolutionAnalysis on Initrand
Running pass: LoopSimplifyPass on Initrand (2 instructions)
Running pass: LCSSAPass on Initrand (2 instructions)
Running pass: SimplifyCFGPass on Initrand (2 instructions)
Running pass: InstCombinePass on Initrand (2 instructions)
Running pass: LoopSimplifyPass on Initrand (2 instructions)
Running pass: LCSSAPass on Initrand (2 instructions)
Running pass: SROAPass on Initrand (2 instructions)
Running pass: VectorCombinePass on Initrand (2 instructions)
Running pass: MergedLoadStoreMotionPass on Initrand (2 instructions)
Running pass: GVNPass on Initrand (2 instructions)
Running analysis: MemoryDependenceAnalysis on Initrand
Running pass: SCCPPass on Initrand (2 instructions)
Running pass: BDCEPass on Initrand (2 instructions)
Running analysis: DemandedBitsAnalysis on Initrand
Running pass: InstCombinePass on Initrand (2 instructions)
Running pass: JumpThreadingPass on Initrand (2 instructions)
Running analysis: LazyValueAnalysis on Initrand
Running pass: CorrelatedValuePropagationPass on Initrand (2 instructions)
Invalidating analysis: LazyValueAnalysis on Initrand
Running pass: ADCEPass on Initrand (2 instructions)
Running analysis: PostDominatorTreeAnalysis on Initrand
Running pass: MemCpyOptPass on Initrand (2 instructions)
Running pass: DSEPass on Initrand (2 instructions)
Running pass: MoveAutoInitPass on Initrand (2 instructions)
Running pass: LoopSimplifyPass on Initrand (2 instructions)
Running pass: LCSSAPass on Initrand (2 instructions)
Running pass: CoroElidePass on Initrand (2 instructions)
Running pass: SimplifyCFGPass on Initrand (2 instructions)
Running pass: InstCombinePass on Initrand (2 instructions)
Invalidating analysis: DominatorTreeAnalysis on Initrand
Invalidating analysis: BasicAA on Initrand
Invalidating analysis: AAManager on Initrand
Invalidating analysis: MemorySSAAnalysis on Initrand
Invalidating analysis: LoopAnalysis on Initrand
Invalidating analysis: ScalarEvolutionAnalysis on Initrand
Invalidating analysis: MemoryDependenceAnalysis on Initrand
Invalidating analysis: DemandedBitsAnalysis on Initrand
Invalidating analysis: PostDominatorTreeAnalysis on Initrand
Running pass: PostOrderFunctionAttrsPass on (Initrand) (1 node)
Running analysis: AAManager on Initrand
Running analysis: BasicAA on Initrand
Running analysis: DominatorTreeAnalysis on Initrand
Running pass: RequireAnalysisPass<ShouldNotRunFunctionPassesAnalysis, Function> on Initrand (2 instructions)
Running analysis: ShouldNotRunFunctionPassesAnalysis on Initrand
Running pass: CoroSplitPass on (Initrand) (1 node)
Running analysis: FunctionAnalysisManagerCGSCCProxy on (Rand)
Running analysis: OuterAnalysisManagerProxy<AnalysisManager<Module>, LazyCallGraph::SCC, LazyCallGraph&> on (Rand)
Running pass: DevirtSCCRepeatedPass on (Rand) (1 node)
Running pass: InlinerPass on (Rand) (1 node)
Running pass: PostOrderFunctionAttrsPass on (Rand) (1 node)
Running pass: ArgumentPromotionPass on (Rand) (1 node)
Running pass: OpenMPOptCGSCCPass on (Rand) (1 node)
Running pass: SROAPass on Rand (7 instructions)
Running analysis: DominatorTreeAnalysis on Rand
Running pass: EarlyCSEPass on Rand (7 instructions)
Running analysis: MemorySSAAnalysis on Rand
Running analysis: AAManager on Rand
Running analysis: BasicAA on Rand
Running pass: SpeculativeExecutionPass on Rand (7 instructions)
Running pass: JumpThreadingPass on Rand (7 instructions)
Running analysis: LazyValueAnalysis on Rand
Running pass: CorrelatedValuePropagationPass on Rand (7 instructions)
Invalidating analysis: LazyValueAnalysis on Rand
Running pass: SimplifyCFGPass on Rand (7 instructions)
Running pass: InstCombinePass on Rand (7 instructions)
Running pass: AggressiveInstCombinePass on Rand (7 instructions)
Running pass: LibCallsShrinkWrapPass on Rand (7 instructions)
Running pass: TailCallElimPass on Rand (7 instructions)
Running pass: SimplifyCFGPass on Rand (7 instructions)
Running pass: ReassociatePass on Rand (7 instructions)
Running pass: ConstraintEliminationPass on Rand (7 instructions)
Running analysis: LoopAnalysis on Rand
Running analysis: ScalarEvolutionAnalysis on Rand
Running pass: LoopSimplifyPass on Rand (7 instructions)
Running pass: LCSSAPass on Rand (7 instructions)
Running pass: SimplifyCFGPass on Rand (7 instructions)
Running pass: InstCombinePass on Rand (7 instructions)
Running pass: LoopSimplifyPass on Rand (7 instructions)
Running pass: LCSSAPass on Rand (7 instructions)
Running pass: SROAPass on Rand (7 instructions)
Running pass: VectorCombinePass on Rand (7 instructions)
Running pass: MergedLoadStoreMotionPass on Rand (7 instructions)
Running pass: GVNPass on Rand (7 instructions)
Running analysis: MemoryDependenceAnalysis on Rand
Running pass: SCCPPass on Rand (7 instructions)
Running pass: BDCEPass on Rand (7 instructions)
Running analysis: DemandedBitsAnalysis on Rand
Running pass: InstCombinePass on Rand (7 instructions)
Running pass: JumpThreadingPass on Rand (7 instructions)
Running analysis: LazyValueAnalysis on Rand
Running pass: CorrelatedValuePropagationPass on Rand (7 instructions)
Invalidating analysis: LazyValueAnalysis on Rand
Running pass: ADCEPass on Rand (7 instructions)
Running analysis: PostDominatorTreeAnalysis on Rand
Running pass: MemCpyOptPass on Rand (7 instructions)
Running pass: DSEPass on Rand (7 instructions)
Running pass: MoveAutoInitPass on Rand (7 instructions)
Running pass: LoopSimplifyPass on Rand (7 instructions)
Running pass: LCSSAPass on Rand (7 instructions)
Running pass: CoroElidePass on Rand (7 instructions)
Running pass: SimplifyCFGPass on Rand (7 instructions)
Running pass: InstCombinePass on Rand (7 instructions)
Invalidating analysis: DominatorTreeAnalysis on Rand
Invalidating analysis: BasicAA on Rand
Invalidating analysis: AAManager on Rand
Invalidating analysis: MemorySSAAnalysis on Rand
Invalidating analysis: LoopAnalysis on Rand
Invalidating analysis: ScalarEvolutionAnalysis on Rand
Invalidating analysis: MemoryDependenceAnalysis on Rand
Invalidating analysis: DemandedBitsAnalysis on Rand
Invalidating analysis: PostDominatorTreeAnalysis on Rand
Running pass: PostOrderFunctionAttrsPass on (Rand) (1 node)
Running analysis: AAManager on Rand
Running analysis: BasicAA on Rand
Running analysis: DominatorTreeAnalysis on Rand
Running pass: RequireAnalysisPass<ShouldNotRunFunctionPassesAnalysis, Function> on Rand (7 instructions)
Running analysis: ShouldNotRunFunctionPassesAnalysis on Rand
Running pass: CoroSplitPass on (Rand) (1 node)
Running analysis: FunctionAnalysisManagerCGSCCProxy on (InitArray)
Running analysis: OuterAnalysisManagerProxy<AnalysisManager<Module>, LazyCallGraph::SCC, LazyCallGraph&> on (InitArray)
Running pass: DevirtSCCRepeatedPass on (InitArray) (1 node)
Running pass: InlinerPass on (InitArray) (1 node)
Running analysis: BlockFrequencyAnalysis on InitArray
Running analysis: BranchProbabilityAnalysis on InitArray
Running analysis: LoopAnalysis on InitArray
Running analysis: DominatorTreeAnalysis on InitArray
Running analysis: PostDominatorTreeAnalysis on InitArray
Running analysis: BlockFrequencyAnalysis on Rand
Running analysis: BranchProbabilityAnalysis on Rand
Running analysis: LoopAnalysis on Rand
Running analysis: PostDominatorTreeAnalysis on Rand
Running analysis: AAManager on InitArray
Running analysis: BasicAA on InitArray
Invalidating analysis: DominatorTreeAnalysis on InitArray
Invalidating analysis: LoopAnalysis on InitArray
Invalidating analysis: PostDominatorTreeAnalysis on InitArray
Invalidating analysis: BranchProbabilityAnalysis on InitArray
Invalidating analysis: BlockFrequencyAnalysis on InitArray
Invalidating analysis: BasicAA on InitArray
Invalidating analysis: AAManager on InitArray
Running pass: PostOrderFunctionAttrsPass on (InitArray) (1 node)
Running pass: ArgumentPromotionPass on (InitArray) (1 node)
Running pass: OpenMPOptCGSCCPass on (InitArray) (1 node)
Running pass: SROAPass on InitArray (20 instructions)
Running analysis: DominatorTreeAnalysis on InitArray
Running pass: EarlyCSEPass on InitArray (20 instructions)
Running analysis: MemorySSAAnalysis on InitArray
Running analysis: AAManager on InitArray
Running analysis: BasicAA on InitArray
Running pass: SpeculativeExecutionPass on InitArray (20 instructions)
Running pass: JumpThreadingPass on InitArray (20 instructions)
Running analysis: LazyValueAnalysis on InitArray
Running pass: CorrelatedValuePropagationPass on InitArray (20 instructions)
Invalidating analysis: LazyValueAnalysis on InitArray
Running pass: SimplifyCFGPass on InitArray (20 instructions)
Running pass: InstCombinePass on InitArray (20 instructions)
Invalidating analysis: MemorySSAAnalysis on InitArray
Running pass: AggressiveInstCombinePass on InitArray (20 instructions)
Running pass: LibCallsShrinkWrapPass on InitArray (20 instructions)
Running pass: TailCallElimPass on InitArray (20 instructions)
Running pass: SimplifyCFGPass on InitArray (20 instructions)
Running pass: ReassociatePass on InitArray (20 instructions)
Running pass: ConstraintEliminationPass on InitArray (20 instructions)
Running analysis: LoopAnalysis on InitArray
Running analysis: ScalarEvolutionAnalysis on InitArray
Running pass: LoopSimplifyPass on InitArray (20 instructions)
Running pass: LCSSAPass on InitArray (20 instructions)
Running analysis: MemorySSAAnalysis on InitArray
Running analysis: InnerAnalysisManagerProxy<AnalysisManager<Loop, LoopStandardAnalysisResults&>, Function> on InitArray
Running pass: LoopInstSimplifyPass on loop %<unnamed loop> in function InitArray
Running pass: LoopSimplifyCFGPass on loop %<unnamed loop> in function InitArray
Running pass: LICMPass on loop %<unnamed loop> in function InitArray
Running pass: LoopRotatePass on loop %<unnamed loop> in function InitArray
Running pass: LICMPass on loop %<unnamed loop> in function InitArray
Running pass: SimpleLoopUnswitchPass on loop %<unnamed loop> in function InitArray
Running analysis: OuterAnalysisManagerProxy<AnalysisManager<Function>, Loop, LoopStandardAnalysisResults&> on loop %<unnamed loop> in function InitArray
Running pass: SimplifyCFGPass on InitArray (24 instructions)
Clearing all analysis results for: <possibly invalidated loop>
Invalidating analysis: DominatorTreeAnalysis on InitArray
Invalidating analysis: BasicAA on InitArray
Invalidating analysis: AAManager on InitArray
Invalidating analysis: LoopAnalysis on InitArray
Invalidating analysis: ScalarEvolutionAnalysis on InitArray
Invalidating analysis: MemorySSAAnalysis on InitArray
Invalidating analysis: InnerAnalysisManagerProxy<AnalysisManager<Loop, LoopStandardAnalysisResults&>, Function> on InitArray
Running pass: InstCombinePass on InitArray (23 instructions)
Running analysis: DominatorTreeAnalysis on InitArray
Running analysis: AAManager on InitArray
Running analysis: BasicAA on InitArray
Running pass: LoopSimplifyPass on InitArray (22 instructions)
Running analysis: LoopAnalysis on InitArray
Running pass: LCSSAPass on InitArray (23 instructions)
Running analysis: ScalarEvolutionAnalysis on InitArray
Running analysis: InnerAnalysisManagerProxy<AnalysisManager<Loop, LoopStandardAnalysisResults&>, Function> on InitArray
Running pass: LoopIdiomRecognizePass on loop %.lr.ph in function InitArray
Running pass: IndVarSimplifyPass on loop %.lr.ph in function InitArray
Running pass: LoopDeletionPass on loop %.lr.ph in function InitArray
Running pass: LoopFullUnrollPass on loop %.lr.ph in function InitArray
Running pass: SROAPass on InitArray (24 instructions)
Running pass: VectorCombinePass on InitArray (24 instructions)
Running pass: MergedLoadStoreMotionPass on InitArray (24 instructions)
Running pass: GVNPass on InitArray (24 instructions)
Running analysis: MemoryDependenceAnalysis on InitArray
Clearing all analysis results for: <possibly invalidated loop>
Invalidating analysis: ScalarEvolutionAnalysis on InitArray
Invalidating analysis: InnerAnalysisManagerProxy<AnalysisManager<Loop, LoopStandardAnalysisResults&>, Function> on InitArray
Invalidating analysis: MemoryDependenceAnalysis on InitArray
Running pass: SCCPPass on InitArray (23 instructions)
Running pass: BDCEPass on InitArray (23 instructions)
Running analysis: DemandedBitsAnalysis on InitArray
Running pass: InstCombinePass on InitArray (23 instructions)
Invalidating analysis: DemandedBitsAnalysis on InitArray
Running pass: JumpThreadingPass on InitArray (23 instructions)
Running analysis: LazyValueAnalysis on InitArray
Running pass: CorrelatedValuePropagationPass on InitArray (23 instructions)
Invalidating analysis: LoopAnalysis on InitArray
Invalidating analysis: LazyValueAnalysis on InitArray
Running pass: ADCEPass on InitArray (25 instructions)
Running analysis: PostDominatorTreeAnalysis on InitArray
Running pass: MemCpyOptPass on InitArray (25 instructions)
Running analysis: MemorySSAAnalysis on InitArray
Running pass: DSEPass on InitArray (25 instructions)
Running analysis: LoopAnalysis on InitArray
Running pass: MoveAutoInitPass on InitArray (25 instructions)
Running pass: LoopSimplifyPass on InitArray (25 instructions)
Running pass: LCSSAPass on InitArray (25 instructions)
Running analysis: ScalarEvolutionAnalysis on InitArray
Running analysis: InnerAnalysisManagerProxy<AnalysisManager<Loop, LoopStandardAnalysisResults&>, Function> on InitArray
Running pass: LICMPass on loop %.lr.ph in function InitArray
Running pass: CoroElidePass on InitArray (26 instructions)
Running pass: SimplifyCFGPass on InitArray (26 instructions)
Running pass: InstCombinePass on InitArray (26 instructions)
Invalidating analysis: MemorySSAAnalysis on InitArray
Invalidating analysis: ScalarEvolutionAnalysis on InitArray
Invalidating analysis: InnerAnalysisManagerProxy<AnalysisManager<Loop, LoopStandardAnalysisResults&>, Function> on InitArray
Invalidating analysis: DominatorTreeAnalysis on InitArray
Invalidating analysis: BasicAA on InitArray
Invalidating analysis: AAManager on InitArray
Invalidating analysis: PostDominatorTreeAnalysis on InitArray
Invalidating analysis: LoopAnalysis on InitArray
Running pass: PostOrderFunctionAttrsPass on (InitArray) (1 node)
Running analysis: AAManager on InitArray
Running analysis: BasicAA on InitArray
Running analysis: DominatorTreeAnalysis on InitArray
Running pass: RequireAnalysisPass<ShouldNotRunFunctionPassesAnalysis, Function> on InitArray (24 instructions)
Running analysis: ShouldNotRunFunctionPassesAnalysis on InitArray
Running pass: CoroSplitPass on (InitArray) (1 node)
Running analysis: FunctionAnalysisManagerCGSCCProxy on (init)
Running analysis: OuterAnalysisManagerProxy<AnalysisManager<Module>, LazyCallGraph::SCC, LazyCallGraph&> on (init)
Running pass: DevirtSCCRepeatedPass on (init) (1 node)
Running pass: InlinerPass on (init) (1 node)
Running analysis: BlockFrequencyAnalysis on init
Running analysis: BranchProbabilityAnalysis on init
Running analysis: LoopAnalysis on init
Running analysis: DominatorTreeAnalysis on init
Running analysis: PostDominatorTreeAnalysis on init
Running analysis: BlockFrequencyAnalysis on Initrand
Running analysis: BranchProbabilityAnalysis on Initrand
Running analysis: LoopAnalysis on Initrand
Running analysis: PostDominatorTreeAnalysis on Initrand
Running analysis: AAManager on init
Running analysis: BasicAA on init
Running analysis: BlockFrequencyAnalysis on InitArray
Running analysis: BranchProbabilityAnalysis on InitArray
Running analysis: LoopAnalysis on InitArray
Running analysis: PostDominatorTreeAnalysis on InitArray
Invalidating analysis: DominatorTreeAnalysis on init
Invalidating analysis: LoopAnalysis on init
Invalidating analysis: PostDominatorTreeAnalysis on init
Invalidating analysis: BranchProbabilityAnalysis on init
Invalidating analysis: BlockFrequencyAnalysis on init
Invalidating analysis: BasicAA on init
Invalidating analysis: AAManager on init
Running pass: PostOrderFunctionAttrsPass on (init) (1 node)
Running pass: ArgumentPromotionPass on (init) (1 node)
Running pass: OpenMPOptCGSCCPass on (init) (1 node)
Running pass: SROAPass on init (74 instructions)
Running analysis: DominatorTreeAnalysis on init
Running pass: EarlyCSEPass on init (74 instructions)
Running analysis: MemorySSAAnalysis on init
Running analysis: AAManager on init
Running analysis: BasicAA on init
Running pass: SpeculativeExecutionPass on init (64 instructions)
Running pass: JumpThreadingPass on init (64 instructions)
Running analysis: LazyValueAnalysis on init
Invalidating analysis: MemorySSAAnalysis on init
Running pass: CorrelatedValuePropagationPass on init (62 instructions)
Invalidating analysis: LazyValueAnalysis on init
Running pass: SimplifyCFGPass on init (62 instructions)
Running pass: InstCombinePass on init (62 instructions)
Running pass: AggressiveInstCombinePass on init (62 instructions)
Running pass: LibCallsShrinkWrapPass on init (62 instructions)
Running pass: TailCallElimPass on init (62 instructions)
Running pass: SimplifyCFGPass on init (62 instructions)
Running pass: ReassociatePass on init (62 instructions)
Running pass: ConstraintEliminationPass on init (62 instructions)
Running analysis: LoopAnalysis on init
Running analysis: ScalarEvolutionAnalysis on init
Running pass: LoopSimplifyPass on init (62 instructions)
Running pass: LCSSAPass on init (62 instructions)
Running analysis: MemorySSAAnalysis on init
Running analysis: InnerAnalysisManagerProxy<AnalysisManager<Loop, LoopStandardAnalysisResults&>, Function> on init
Running pass: LoopInstSimplifyPass on loop %.lr.ph.i in function init
Running pass: LoopSimplifyCFGPass on loop %.lr.ph.i in function init
Running pass: LICMPass on loop %.lr.ph.i in function init
Running pass: LoopRotatePass on loop %.lr.ph.i in function init
Running pass: LICMPass on loop %.lr.ph.i in function init
Running pass: SimpleLoopUnswitchPass on loop %.lr.ph.i in function init
Running analysis: OuterAnalysisManagerProxy<AnalysisManager<Function>, Loop, LoopStandardAnalysisResults&> on loop %.lr.ph.i in function init
Running pass: LoopInstSimplifyPass on loop %.lr.ph.i11 in function init
Running pass: LoopSimplifyCFGPass on loop %.lr.ph.i11 in function init
Running pass: LICMPass on loop %.lr.ph.i11 in function init
Running pass: LoopRotatePass on loop %.lr.ph.i11 in function init
Running pass: LICMPass on loop %.lr.ph.i11 in function init
Running pass: SimpleLoopUnswitchPass on loop %.lr.ph.i11 in function init
Running analysis: OuterAnalysisManagerProxy<AnalysisManager<Function>, Loop, LoopStandardAnalysisResults&> on loop %.lr.ph.i11 in function init
Running pass: SimplifyCFGPass on init (64 instructions)
Clearing all analysis results for: <possibly invalidated loop>
Clearing all analysis results for: <possibly invalidated loop>
Invalidating analysis: DominatorTreeAnalysis on init
Invalidating analysis: BasicAA on init
Invalidating analysis: AAManager on init
Invalidating analysis: LoopAnalysis on init
Invalidating analysis: ScalarEvolutionAnalysis on init
Invalidating analysis: MemorySSAAnalysis on init
Invalidating analysis: InnerAnalysisManagerProxy<AnalysisManager<Loop, LoopStandardAnalysisResults&>, Function> on init
Running pass: InstCombinePass on init (63 instructions)
Running analysis: DominatorTreeAnalysis on init
Running analysis: AAManager on init
Running analysis: BasicAA on init
Running pass: LoopSimplifyPass on init (59 instructions)
Running analysis: LoopAnalysis on init
Running pass: LCSSAPass on init (59 instructions)
Running analysis: ScalarEvolutionAnalysis on init
Running analysis: InnerAnalysisManagerProxy<AnalysisManager<Loop, LoopStandardAnalysisResults&>, Function> on init
Running pass: LoopIdiomRecognizePass on loop %.lr.ph.i in function init
Running pass: IndVarSimplifyPass on loop %.lr.ph.i in function init
Running pass: LoopDeletionPass on loop %.lr.ph.i in function init
Running pass: LoopFullUnrollPass on loop %.lr.ph.i in function init
Running pass: LoopIdiomRecognizePass on loop %.lr.ph.i11 in function init
Running pass: IndVarSimplifyPass on loop %.lr.ph.i11 in function init
Running pass: LoopDeletionPass on loop %.lr.ph.i11 in function init
Running pass: LoopFullUnrollPass on loop %.lr.ph.i11 in function init
Running pass: SROAPass on init (61 instructions)
Running pass: VectorCombinePass on init (61 instructions)
Running pass: MergedLoadStoreMotionPass on init (61 instructions)
Running pass: GVNPass on init (61 instructions)
Running analysis: MemoryDependenceAnalysis on init
Clearing all analysis results for: <possibly invalidated loop>
Clearing all analysis results for: <possibly invalidated loop>
Invalidating analysis: ScalarEvolutionAnalysis on init
Invalidating analysis: InnerAnalysisManagerProxy<AnalysisManager<Loop, LoopStandardAnalysisResults&>, Function> on init
Invalidating analysis: MemoryDependenceAnalysis on init
Running pass: SCCPPass on init (58 instructions)
Running pass: BDCEPass on init (58 instructions)
Running analysis: DemandedBitsAnalysis on init
Running pass: InstCombinePass on init (58 instructions)
Running pass: JumpThreadingPass on init (58 instructions)
Running analysis: LazyValueAnalysis on init
Running pass: CorrelatedValuePropagationPass on init (58 instructions)
Invalidating analysis: LazyValueAnalysis on init
Running pass: ADCEPass on init (58 instructions)
Running analysis: PostDominatorTreeAnalysis on init
Running pass: MemCpyOptPass on init (58 instructions)
Running analysis: MemorySSAAnalysis on init
Running pass: DSEPass on init (58 instructions)
Invalidating analysis: DemandedBitsAnalysis on init
Running pass: MoveAutoInitPass on init (57 instructions)
Running pass: LoopSimplifyPass on init (57 instructions)
Running pass: LCSSAPass on init (57 instructions)
Running analysis: ScalarEvolutionAnalysis on init
Running analysis: InnerAnalysisManagerProxy<AnalysisManager<Loop, LoopStandardAnalysisResults&>, Function> on init
Running pass: LICMPass on loop %.lr.ph.i in function init
Running pass: LICMPass on loop %.lr.ph.i11 in function init
Running pass: CoroElidePass on init (59 instructions)
Running pass: SimplifyCFGPass on init (59 instructions)
Invalidating analysis: DominatorTreeAnalysis on init
Invalidating analysis: BasicAA on init
Invalidating analysis: AAManager on init
Invalidating analysis: LoopAnalysis on init
Invalidating analysis: PostDominatorTreeAnalysis on init
Invalidating analysis: MemorySSAAnalysis on init
Invalidating analysis: ScalarEvolutionAnalysis on init
Invalidating analysis: InnerAnalysisManagerProxy<AnalysisManager<Loop, LoopStandardAnalysisResults&>, Function> on init
Running pass: InstCombinePass on init (57 instructions)
Running analysis: DominatorTreeAnalysis on init
Running analysis: AAManager on init
Running analysis: BasicAA on init
Invalidating analysis: DominatorTreeAnalysis on init
Invalidating analysis: BasicAA on init
Invalidating analysis: AAManager on init
Running pass: PostOrderFunctionAttrsPass on (init) (1 node)
Running analysis: AAManager on init
Running analysis: BasicAA on init
Running analysis: DominatorTreeAnalysis on init
Running pass: RequireAnalysisPass<ShouldNotRunFunctionPassesAnalysis, Function> on init (56 instructions)
Running analysis: ShouldNotRunFunctionPassesAnalysis on init
Running pass: CoroSplitPass on (init) (1 node)
Running analysis: FunctionAnalysisManagerCGSCCProxy on (deinit)
Running analysis: OuterAnalysisManagerProxy<AnalysisManager<Module>, LazyCallGraph::SCC, LazyCallGraph&> on (deinit)
Running pass: DevirtSCCRepeatedPass on (deinit) (1 node)
Running pass: InlinerPass on (deinit) (1 node)
Running pass: PostOrderFunctionAttrsPass on (deinit) (1 node)
Running pass: ArgumentPromotionPass on (deinit) (1 node)
Running pass: OpenMPOptCGSCCPass on (deinit) (1 node)
Running pass: SROAPass on deinit (7 instructions)
Running analysis: DominatorTreeAnalysis on deinit
Running pass: EarlyCSEPass on deinit (7 instructions)
Running analysis: MemorySSAAnalysis on deinit
Running analysis: AAManager on deinit
Running analysis: BasicAA on deinit
Running pass: SpeculativeExecutionPass on deinit (7 instructions)
Running pass: JumpThreadingPass on deinit (7 instructions)
Running analysis: LazyValueAnalysis on deinit
Running pass: CorrelatedValuePropagationPass on deinit (7 instructions)
Invalidating analysis: LazyValueAnalysis on deinit
Running pass: SimplifyCFGPass on deinit (7 instructions)
Running pass: InstCombinePass on deinit (7 instructions)
Running pass: AggressiveInstCombinePass on deinit (7 instructions)
Running pass: LibCallsShrinkWrapPass on deinit (7 instructions)
Running pass: TailCallElimPass on deinit (7 instructions)
Invalidating analysis: MemorySSAAnalysis on deinit
Running pass: SimplifyCFGPass on deinit (7 instructions)
Running pass: ReassociatePass on deinit (7 instructions)
Running pass: ConstraintEliminationPass on deinit (7 instructions)
Running analysis: LoopAnalysis on deinit
Running analysis: ScalarEvolutionAnalysis on deinit
Running pass: LoopSimplifyPass on deinit (7 instructions)
Running pass: LCSSAPass on deinit (7 instructions)
Running pass: SimplifyCFGPass on deinit (7 instructions)
Running pass: InstCombinePass on deinit (7 instructions)
Running pass: LoopSimplifyPass on deinit (7 instructions)
Running pass: LCSSAPass on deinit (7 instructions)
Running pass: SROAPass on deinit (7 instructions)
Running pass: VectorCombinePass on deinit (7 instructions)
Running pass: MergedLoadStoreMotionPass on deinit (7 instructions)
Running pass: GVNPass on deinit (7 instructions)
Running analysis: MemoryDependenceAnalysis on deinit
Running pass: SCCPPass on deinit (7 instructions)
Running pass: BDCEPass on deinit (7 instructions)
Running analysis: DemandedBitsAnalysis on deinit
Running pass: InstCombinePass on deinit (7 instructions)
Running pass: JumpThreadingPass on deinit (7 instructions)
Running analysis: LazyValueAnalysis on deinit
Running pass: CorrelatedValuePropagationPass on deinit (7 instructions)
Invalidating analysis: LazyValueAnalysis on deinit
Running pass: ADCEPass on deinit (7 instructions)
Running analysis: PostDominatorTreeAnalysis on deinit
Running pass: MemCpyOptPass on deinit (7 instructions)
Running analysis: MemorySSAAnalysis on deinit
Running pass: DSEPass on deinit (7 instructions)
Running pass: MoveAutoInitPass on deinit (7 instructions)
Running pass: LoopSimplifyPass on deinit (7 instructions)
Running pass: LCSSAPass on deinit (7 instructions)
Running pass: CoroElidePass on deinit (7 instructions)
Running pass: SimplifyCFGPass on deinit (7 instructions)
Running pass: InstCombinePass on deinit (7 instructions)
Invalidating analysis: DominatorTreeAnalysis on deinit
Invalidating analysis: BasicAA on deinit
Invalidating analysis: AAManager on deinit
Invalidating analysis: LoopAnalysis on deinit
Invalidating analysis: ScalarEvolutionAnalysis on deinit
Invalidating analysis: MemoryDependenceAnalysis on deinit
Invalidating analysis: DemandedBitsAnalysis on deinit
Invalidating analysis: PostDominatorTreeAnalysis on deinit
Invalidating analysis: MemorySSAAnalysis on deinit
Running pass: PostOrderFunctionAttrsPass on (deinit) (1 node)
Running analysis: AAManager on deinit
Running analysis: BasicAA on deinit
Running analysis: DominatorTreeAnalysis on deinit
Running pass: RequireAnalysisPass<ShouldNotRunFunctionPassesAnalysis, Function> on deinit (7 instructions)
Running analysis: ShouldNotRunFunctionPassesAnalysis on deinit
Running pass: CoroSplitPass on (deinit) (1 node)
Running analysis: FunctionAnalysisManagerCGSCCProxy on (sum_1)
Running analysis: OuterAnalysisManagerProxy<AnalysisManager<Module>, LazyCallGraph::SCC, LazyCallGraph&> on (sum_1)
Running pass: DevirtSCCRepeatedPass on (sum_1) (1 node)
Running pass: InlinerPass on (sum_1) (1 node)
; *** IR Dump After InlinerPass on (sum_1) ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !5
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %16, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %15, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %17

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !9
  %6 = zext nneg i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !5
  %9 = load ptr, ptr @imb, align 8, !tbaa !9
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !5
  %12 = add nsw i32 %8, %11
  %13 = load ptr, ptr @imr, align 8, !tbaa !9
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !5
  %15 = add i32 %.0, %12
  %16 = add nuw nsw i32 %.09, 1
  br label %2, !llvm.loop !11

17:                                               ; preds = %2
  ret i32 %.0
}
Running pass: PostOrderFunctionAttrsPass on (sum_1) (1 node)
; *** IR Dump After PostOrderFunctionAttrsPass on (sum_1) ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !5
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %16, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %15, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %17

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !9
  %6 = zext nneg i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !5
  %9 = load ptr, ptr @imb, align 8, !tbaa !9
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !5
  %12 = add nsw i32 %8, %11
  %13 = load ptr, ptr @imr, align 8, !tbaa !9
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !5
  %15 = add i32 %.0, %12
  %16 = add nuw nsw i32 %.09, 1
  br label %2, !llvm.loop !11

17:                                               ; preds = %2
  ret i32 %.0
}
Running pass: ArgumentPromotionPass on (sum_1) (1 node)
; *** IR Dump After ArgumentPromotionPass on (sum_1) ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !5
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %16, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %15, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %17

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !9
  %6 = zext nneg i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !5
  %9 = load ptr, ptr @imb, align 8, !tbaa !9
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !5
  %12 = add nsw i32 %8, %11
  %13 = load ptr, ptr @imr, align 8, !tbaa !9
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !5
  %15 = add i32 %.0, %12
  %16 = add nuw nsw i32 %.09, 1
  br label %2, !llvm.loop !11

17:                                               ; preds = %2
  ret i32 %.0
}
Running pass: OpenMPOptCGSCCPass on (sum_1) (1 node)
; *** IR Dump After OpenMPOptCGSCCPass on (sum_1) ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !5
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %16, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %15, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %17

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !9
  %6 = zext nneg i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !5
  %9 = load ptr, ptr @imb, align 8, !tbaa !9
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !5
  %12 = add nsw i32 %8, %11
  %13 = load ptr, ptr @imr, align 8, !tbaa !9
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !5
  %15 = add i32 %.0, %12
  %16 = add nuw nsw i32 %.09, 1
  br label %2, !llvm.loop !11

17:                                               ; preds = %2
  ret i32 %.0
}
Running pass: SROAPass on sum_1 (21 instructions)
Running analysis: DominatorTreeAnalysis on sum_1
; *** IR Dump After SROAPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %16, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %15, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %17

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !14
  %6 = zext nneg i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = load ptr, ptr @imb, align 8, !tbaa !14
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !9
  %12 = add nsw i32 %8, %11
  %13 = load ptr, ptr @imr, align 8, !tbaa !14
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !9
  %15 = add i32 %.0, %12
  %16 = add nuw nsw i32 %.09, 1
  br label %2, !llvm.loop !16

17:                                               ; preds = %2
  ret i32 %.0
}
Running pass: EarlyCSEPass on sum_1 (21 instructions)
Running analysis: MemorySSAAnalysis on sum_1
Running analysis: AAManager on sum_1
Running analysis: BasicAA on sum_1
; *** IR Dump After EarlyCSEPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %16, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %15, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %17

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !14
  %6 = zext nneg i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = load ptr, ptr @imb, align 8, !tbaa !14
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !9
  %12 = add nsw i32 %8, %11
  %13 = load ptr, ptr @imr, align 8, !tbaa !14
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !9
  %15 = add i32 %.0, %12
  %16 = add nuw nsw i32 %.09, 1
  br label %2, !llvm.loop !16

17:                                               ; preds = %2
  ret i32 %.0
}
Running pass: SpeculativeExecutionPass on sum_1 (21 instructions)
; *** IR Dump After SpeculativeExecutionPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %16, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %15, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %17

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !14
  %6 = zext nneg i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = load ptr, ptr @imb, align 8, !tbaa !14
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !9
  %12 = add nsw i32 %8, %11
  %13 = load ptr, ptr @imr, align 8, !tbaa !14
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !9
  %15 = add i32 %.0, %12
  %16 = add nuw nsw i32 %.09, 1
  br label %2, !llvm.loop !16

17:                                               ; preds = %2
  ret i32 %.0
}
Running pass: JumpThreadingPass on sum_1 (21 instructions)
Running analysis: LazyValueAnalysis on sum_1
; *** IR Dump After JumpThreadingPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %16, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %15, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %17

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !14
  %6 = zext nneg i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = load ptr, ptr @imb, align 8, !tbaa !14
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !9
  %12 = add nsw i32 %8, %11
  %13 = load ptr, ptr @imr, align 8, !tbaa !14
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !9
  %15 = add i32 %.0, %12
  %16 = add nuw nsw i32 %.09, 1
  br label %2, !llvm.loop !16

17:                                               ; preds = %2
  ret i32 %.0
}
Running pass: CorrelatedValuePropagationPass on sum_1 (21 instructions)
Invalidating analysis: LazyValueAnalysis on sum_1
; *** IR Dump After CorrelatedValuePropagationPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %16, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %15, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %17

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !14
  %6 = zext nneg i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = load ptr, ptr @imb, align 8, !tbaa !14
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !9
  %12 = add nsw i32 %8, %11
  %13 = load ptr, ptr @imr, align 8, !tbaa !14
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !9
  %15 = add i32 %.0, %12
  %16 = add nuw nsw i32 %.09, 1
  br label %2, !llvm.loop !16

17:                                               ; preds = %2
  ret i32 %.0
}
Running pass: SimplifyCFGPass on sum_1 (21 instructions)
; *** IR Dump After SimplifyCFGPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %16, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %15, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %17

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !14
  %6 = zext nneg i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = load ptr, ptr @imb, align 8, !tbaa !14
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !9
  %12 = add nsw i32 %8, %11
  %13 = load ptr, ptr @imr, align 8, !tbaa !14
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !9
  %15 = add i32 %.0, %12
  %16 = add nuw nsw i32 %.09, 1
  br label %2, !llvm.loop !16

17:                                               ; preds = %2
  ret i32 %.0
}
Running pass: InstCombinePass on sum_1 (21 instructions)
; *** IR Dump After InstCombinePass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %16, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %15, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %17

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !14
  %6 = zext nneg i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = load ptr, ptr @imb, align 8, !tbaa !14
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !9
  %12 = add nsw i32 %8, %11
  %13 = load ptr, ptr @imr, align 8, !tbaa !14
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !9
  %15 = add i32 %.0, %12
  %16 = add nuw nsw i32 %.09, 1
  br label %2, !llvm.loop !16

17:                                               ; preds = %2
  ret i32 %.0
}
Running pass: AggressiveInstCombinePass on sum_1 (21 instructions)
; *** IR Dump After AggressiveInstCombinePass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %16, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %15, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %17

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !14
  %6 = zext nneg i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = load ptr, ptr @imb, align 8, !tbaa !14
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !9
  %12 = add nsw i32 %8, %11
  %13 = load ptr, ptr @imr, align 8, !tbaa !14
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !9
  %15 = add i32 %.0, %12
  %16 = add nuw nsw i32 %.09, 1
  br label %2, !llvm.loop !16

17:                                               ; preds = %2
  ret i32 %.0
}
Running pass: LibCallsShrinkWrapPass on sum_1 (21 instructions)
; *** IR Dump After LibCallsShrinkWrapPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %16, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %15, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %17

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !14
  %6 = zext nneg i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = load ptr, ptr @imb, align 8, !tbaa !14
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !9
  %12 = add nsw i32 %8, %11
  %13 = load ptr, ptr @imr, align 8, !tbaa !14
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !9
  %15 = add i32 %.0, %12
  %16 = add nuw nsw i32 %.09, 1
  br label %2, !llvm.loop !16

17:                                               ; preds = %2
  ret i32 %.0
}
Running pass: TailCallElimPass on sum_1 (21 instructions)
; *** IR Dump After TailCallElimPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %16, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %15, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %17

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !14
  %6 = zext nneg i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = load ptr, ptr @imb, align 8, !tbaa !14
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !9
  %12 = add nsw i32 %8, %11
  %13 = load ptr, ptr @imr, align 8, !tbaa !14
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !9
  %15 = add i32 %.0, %12
  %16 = add nuw nsw i32 %.09, 1
  br label %2, !llvm.loop !16

17:                                               ; preds = %2
  ret i32 %.0
}
Running pass: SimplifyCFGPass on sum_1 (21 instructions)
; *** IR Dump After SimplifyCFGPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %16, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %15, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %17

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !14
  %6 = zext nneg i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = load ptr, ptr @imb, align 8, !tbaa !14
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !9
  %12 = add nsw i32 %8, %11
  %13 = load ptr, ptr @imr, align 8, !tbaa !14
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !9
  %15 = add i32 %.0, %12
  %16 = add nuw nsw i32 %.09, 1
  br label %2, !llvm.loop !16

17:                                               ; preds = %2
  ret i32 %.0
}
Running pass: ReassociatePass on sum_1 (21 instructions)
Invalidating analysis: MemorySSAAnalysis on sum_1
; *** IR Dump After ReassociatePass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %16, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %15, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %17

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !14
  %6 = zext nneg i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = load ptr, ptr @imb, align 8, !tbaa !14
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !9
  %12 = add nsw i32 %11, %8
  %13 = load ptr, ptr @imr, align 8, !tbaa !14
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !9
  %15 = add i32 %12, %.0
  %16 = add nuw nsw i32 %.09, 1
  br label %2, !llvm.loop !16

17:                                               ; preds = %2
  ret i32 %.0
}
Running pass: ConstraintEliminationPass on sum_1 (21 instructions)
Running analysis: LoopAnalysis on sum_1
Running analysis: ScalarEvolutionAnalysis on sum_1
; *** IR Dump After ConstraintEliminationPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %16, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %15, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %17

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !14
  %6 = zext nneg i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = load ptr, ptr @imb, align 8, !tbaa !14
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !9
  %12 = add nsw i32 %11, %8
  %13 = load ptr, ptr @imr, align 8, !tbaa !14
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !9
  %15 = add i32 %12, %.0
  %16 = add nuw nsw i32 %.09, 1
  br label %2, !llvm.loop !16

17:                                               ; preds = %2
  ret i32 %.0
}
Running pass: LoopSimplifyPass on sum_1 (21 instructions)
; *** IR Dump After LoopSimplifyPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %16, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %15, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %17

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !14
  %6 = zext nneg i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = load ptr, ptr @imb, align 8, !tbaa !14
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !9
  %12 = add nsw i32 %11, %8
  %13 = load ptr, ptr @imr, align 8, !tbaa !14
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !9
  %15 = add i32 %12, %.0
  %16 = add nuw nsw i32 %.09, 1
  br label %2, !llvm.loop !16

17:                                               ; preds = %2
  ret i32 %.0
}
Running pass: LCSSAPass on sum_1 (21 instructions)
; *** IR Dump After LCSSAPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  br label %2

2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %16, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %15, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %17

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !14
  %6 = zext nneg i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = load ptr, ptr @imb, align 8, !tbaa !14
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !9
  %12 = add nsw i32 %11, %8
  %13 = load ptr, ptr @imr, align 8, !tbaa !14
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !9
  %15 = add i32 %12, %.0
  %16 = add nuw nsw i32 %.09, 1
  br label %2, !llvm.loop !16

17:                                               ; preds = %2
  %.0.lcssa = phi i32 [ %.0, %2 ]
  ret i32 %.0.lcssa
}
Running analysis: MemorySSAAnalysis on sum_1
Running analysis: InnerAnalysisManagerProxy<AnalysisManager<Loop, LoopStandardAnalysisResults&>, Function> on sum_1
Running pass: LoopInstSimplifyPass on loop %<unnamed loop> in function sum_1
; *** IR Dump After LoopInstSimplifyPass on loop %<unnamed loop> in function sum_1 ***

; Preheader:
  %1 = load i32, ptr @size, align 4, !tbaa !5
  br label %2

; Loop:
2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %16, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %15, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %17

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !9
  %6 = zext nneg i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !5
  %9 = load ptr, ptr @imb, align 8, !tbaa !9
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !5
  %12 = add nsw i32 %11, %8
  %13 = load ptr, ptr @imr, align 8, !tbaa !9
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !5
  %15 = add i32 %12, %.0
  %16 = add nuw nsw i32 %.09, 1
  br label %2, !llvm.loop !11

; Exit blocks
17:                                               ; preds = %2
  %.0.lcssa = phi i32 [ %.0, %2 ]
  ret i32 %.0.lcssa
Running pass: LoopSimplifyCFGPass on loop %<unnamed loop> in function sum_1
; *** IR Dump After LoopSimplifyCFGPass on loop %<unnamed loop> in function sum_1 ***

; Preheader:
  %1 = load i32, ptr @size, align 4, !tbaa !5
  br label %2

; Loop:
2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %16, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %15, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %17

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !9
  %6 = zext nneg i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !5
  %9 = load ptr, ptr @imb, align 8, !tbaa !9
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !5
  %12 = add nsw i32 %11, %8
  %13 = load ptr, ptr @imr, align 8, !tbaa !9
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !5
  %15 = add i32 %12, %.0
  %16 = add nuw nsw i32 %.09, 1
  br label %2, !llvm.loop !11

; Exit blocks
17:                                               ; preds = %2
  %.0.lcssa = phi i32 [ %.0, %2 ]
  ret i32 %.0.lcssa
Running pass: LICMPass on loop %<unnamed loop> in function sum_1
; *** IR Dump After LICMPass on loop %<unnamed loop> in function sum_1 ***

; Preheader:
  %1 = load i32, ptr @size, align 4, !tbaa !5
  br label %2

; Loop:
2:                                                ; preds = %4, %0
  %.09 = phi i32 [ 0, %0 ], [ %16, %4 ]
  %.0 = phi i32 [ 0, %0 ], [ %15, %4 ]
  %3 = icmp slt i32 %.09, %1
  br i1 %3, label %4, label %17

4:                                                ; preds = %2
  %5 = load ptr, ptr @ima, align 8, !tbaa !9
  %6 = zext nneg i32 %.09 to i64
  %7 = getelementptr inbounds i32, ptr %5, i64 %6
  %8 = load i32, ptr %7, align 4, !tbaa !5
  %9 = load ptr, ptr @imb, align 8, !tbaa !9
  %10 = getelementptr inbounds i32, ptr %9, i64 %6
  %11 = load i32, ptr %10, align 4, !tbaa !5
  %12 = add nsw i32 %11, %8
  %13 = load ptr, ptr @imr, align 8, !tbaa !9
  %14 = getelementptr inbounds i32, ptr %13, i64 %6
  store i32 %12, ptr %14, align 4, !tbaa !5
  %15 = add i32 %12, %.0
  %16 = add nuw nsw i32 %.09, 1
  br label %2, !llvm.loop !11

; Exit blocks
17:                                               ; preds = %2
  %.0.lcssa = phi i32 [ %.0, %2 ]
  ret i32 %.0.lcssa
Running pass: LoopRotatePass on loop %<unnamed loop> in function sum_1
; *** IR Dump After LoopRotatePass on loop %<unnamed loop> in function sum_1 ***

; Preheader:
.lr.ph:                                           ; preds = %0
  br label %3

; Loop:
3:                                                ; preds = %.lr.ph, %3
  %.011 = phi i32 [ 0, %.lr.ph ], [ %14, %3 ]
  %.0910 = phi i32 [ 0, %.lr.ph ], [ %15, %3 ]
  %4 = load ptr, ptr @ima, align 8, !tbaa !9
  %5 = zext nneg i32 %.0910 to i64
  %6 = getelementptr inbounds i32, ptr %4, i64 %5
  %7 = load i32, ptr %6, align 4, !tbaa !5
  %8 = load ptr, ptr @imb, align 8, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %8, i64 %5
  %10 = load i32, ptr %9, align 4, !tbaa !5
  %11 = add nsw i32 %10, %7
  %12 = load ptr, ptr @imr, align 8, !tbaa !9
  %13 = getelementptr inbounds i32, ptr %12, i64 %5
  store i32 %11, ptr %13, align 4, !tbaa !5
  %14 = add i32 %11, %.011
  %15 = add nuw nsw i32 %.0910, 1
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %3, label %._crit_edge, !llvm.loop !11

; Exit blocks
._crit_edge:                                      ; preds = %3
  %split = phi i32 [ %14, %3 ]
  br label %17
Running pass: LICMPass on loop %<unnamed loop> in function sum_1
; *** IR Dump After LICMPass on loop %<unnamed loop> in function sum_1 ***

; Preheader:
.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !9
  %4 = load ptr, ptr @imb, align 8, !tbaa !9
  %5 = load ptr, ptr @imr, align 8, !tbaa !9
  br label %6

; Loop:
6:                                                ; preds = %.lr.ph, %6
  %.011 = phi i32 [ 0, %.lr.ph ], [ %14, %6 ]
  %.0910 = phi i32 [ 0, %.lr.ph ], [ %15, %6 ]
  %7 = zext nneg i32 %.0910 to i64
  %8 = getelementptr inbounds i32, ptr %3, i64 %7
  %9 = load i32, ptr %8, align 4, !tbaa !5
  %10 = getelementptr inbounds i32, ptr %4, i64 %7
  %11 = load i32, ptr %10, align 4, !tbaa !5
  %12 = add nsw i32 %11, %9
  %13 = getelementptr inbounds i32, ptr %5, i64 %7
  store i32 %12, ptr %13, align 4, !tbaa !5
  %14 = add i32 %12, %.011
  %15 = add nuw nsw i32 %.0910, 1
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %6, label %._crit_edge, !llvm.loop !11

; Exit blocks
._crit_edge:                                      ; preds = %6
  %split = phi i32 [ %14, %6 ]
  br label %17
Running pass: SimpleLoopUnswitchPass on loop %<unnamed loop> in function sum_1
Running analysis: OuterAnalysisManagerProxy<AnalysisManager<Function>, Loop, LoopStandardAnalysisResults&> on loop %<unnamed loop> in function sum_1
; *** IR Dump After SimpleLoopUnswitchPass on loop %<unnamed loop> in function sum_1 ***

; Preheader:
.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !9
  %4 = load ptr, ptr @imb, align 8, !tbaa !9
  %5 = load ptr, ptr @imr, align 8, !tbaa !9
  br label %6

; Loop:
6:                                                ; preds = %.lr.ph, %6
  %.011 = phi i32 [ 0, %.lr.ph ], [ %14, %6 ]
  %.0910 = phi i32 [ 0, %.lr.ph ], [ %15, %6 ]
  %7 = zext nneg i32 %.0910 to i64
  %8 = getelementptr inbounds i32, ptr %3, i64 %7
  %9 = load i32, ptr %8, align 4, !tbaa !5
  %10 = getelementptr inbounds i32, ptr %4, i64 %7
  %11 = load i32, ptr %10, align 4, !tbaa !5
  %12 = add nsw i32 %11, %9
  %13 = getelementptr inbounds i32, ptr %5, i64 %7
  store i32 %12, ptr %13, align 4, !tbaa !5
  %14 = add i32 %12, %.011
  %15 = add nuw nsw i32 %.0910, 1
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %6, label %._crit_edge, !llvm.loop !11

; Exit blocks
._crit_edge:                                      ; preds = %6
  %split = phi i32 [ %14, %6 ]
  br label %17
Running pass: SimplifyCFGPass on sum_1 (25 instructions)
Clearing all analysis results for: <possibly invalidated loop>
Invalidating analysis: DominatorTreeAnalysis on sum_1
Invalidating analysis: BasicAA on sum_1
Invalidating analysis: AAManager on sum_1
Invalidating analysis: LoopAnalysis on sum_1
Invalidating analysis: ScalarEvolutionAnalysis on sum_1
Invalidating analysis: MemorySSAAnalysis on sum_1
Invalidating analysis: InnerAnalysisManagerProxy<AnalysisManager<Loop, LoopStandardAnalysisResults&>, Function> on sum_1
; *** IR Dump After SimplifyCFGPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp slt i32 0, %1
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %.011 = phi i32 [ 0, %.lr.ph ], [ %14, %6 ]
  %.0910 = phi i32 [ 0, %.lr.ph ], [ %15, %6 ]
  %7 = zext nneg i32 %.0910 to i64
  %8 = getelementptr inbounds i32, ptr %3, i64 %7
  %9 = load i32, ptr %8, align 4, !tbaa !9
  %10 = getelementptr inbounds i32, ptr %4, i64 %7
  %11 = load i32, ptr %10, align 4, !tbaa !9
  %12 = add nsw i32 %11, %9
  %13 = getelementptr inbounds i32, ptr %5, i64 %7
  store i32 %12, ptr %13, align 4, !tbaa !9
  %14 = add i32 %12, %.011
  %15 = add nuw nsw i32 %.0910, 1
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %6, label %._crit_edge, !llvm.loop !16

._crit_edge:                                      ; preds = %6, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %14, %6 ]
  ret i32 %.0.lcssa
}
Running pass: InstCombinePass on sum_1 (23 instructions)
Running analysis: DominatorTreeAnalysis on sum_1
Running analysis: AAManager on sum_1
Running analysis: BasicAA on sum_1
; *** IR Dump After InstCombinePass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %.011 = phi i32 [ 0, %.lr.ph ], [ %14, %6 ]
  %.0910 = phi i32 [ 0, %.lr.ph ], [ %15, %6 ]
  %7 = zext nneg i32 %.0910 to i64
  %8 = getelementptr inbounds i32, ptr %3, i64 %7
  %9 = load i32, ptr %8, align 4, !tbaa !9
  %10 = getelementptr inbounds i32, ptr %4, i64 %7
  %11 = load i32, ptr %10, align 4, !tbaa !9
  %12 = add nsw i32 %11, %9
  %13 = getelementptr inbounds i32, ptr %5, i64 %7
  store i32 %12, ptr %13, align 4, !tbaa !9
  %14 = add i32 %12, %.011
  %15 = add nuw nsw i32 %.0910, 1
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %6, label %._crit_edge, !llvm.loop !16

._crit_edge:                                      ; preds = %6, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %14, %6 ]
  ret i32 %.0.lcssa
}
Running pass: LoopSimplifyPass on sum_1 (23 instructions)
Running analysis: LoopAnalysis on sum_1
; *** IR Dump After LoopSimplifyPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %.011 = phi i32 [ 0, %.lr.ph ], [ %14, %6 ]
  %.0910 = phi i32 [ 0, %.lr.ph ], [ %15, %6 ]
  %7 = zext nneg i32 %.0910 to i64
  %8 = getelementptr inbounds i32, ptr %3, i64 %7
  %9 = load i32, ptr %8, align 4, !tbaa !9
  %10 = getelementptr inbounds i32, ptr %4, i64 %7
  %11 = load i32, ptr %10, align 4, !tbaa !9
  %12 = add nsw i32 %11, %9
  %13 = getelementptr inbounds i32, ptr %5, i64 %7
  store i32 %12, ptr %13, align 4, !tbaa !9
  %14 = add i32 %12, %.011
  %15 = add nuw nsw i32 %.0910, 1
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %6, label %._crit_edge.loopexit, !llvm.loop !16

._crit_edge.loopexit:                             ; preds = %6
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %14, %._crit_edge.loopexit ]
  ret i32 %.0.lcssa
}
Running pass: LCSSAPass on sum_1 (24 instructions)
; *** IR Dump After LCSSAPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %.011 = phi i32 [ 0, %.lr.ph ], [ %14, %6 ]
  %.0910 = phi i32 [ 0, %.lr.ph ], [ %15, %6 ]
  %7 = zext nneg i32 %.0910 to i64
  %8 = getelementptr inbounds i32, ptr %3, i64 %7
  %9 = load i32, ptr %8, align 4, !tbaa !9
  %10 = getelementptr inbounds i32, ptr %4, i64 %7
  %11 = load i32, ptr %10, align 4, !tbaa !9
  %12 = add nsw i32 %11, %9
  %13 = getelementptr inbounds i32, ptr %5, i64 %7
  store i32 %12, ptr %13, align 4, !tbaa !9
  %14 = add i32 %12, %.011
  %15 = add nuw nsw i32 %.0910, 1
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %6, label %._crit_edge.loopexit, !llvm.loop !16

._crit_edge.loopexit:                             ; preds = %6
  %.lcssa = phi i32 [ %14, %6 ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %.lcssa, %._crit_edge.loopexit ]
  ret i32 %.0.lcssa
}
Running analysis: ScalarEvolutionAnalysis on sum_1
Running analysis: InnerAnalysisManagerProxy<AnalysisManager<Loop, LoopStandardAnalysisResults&>, Function> on sum_1
Running pass: LoopIdiomRecognizePass on loop %<unnamed loop> in function sum_1
; *** IR Dump After LoopIdiomRecognizePass on loop %<unnamed loop> in function sum_1 ***

; Preheader:
.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !9
  %4 = load ptr, ptr @imb, align 8, !tbaa !9
  %5 = load ptr, ptr @imr, align 8, !tbaa !9
  br label %6

; Loop:
6:                                                ; preds = %.lr.ph, %6
  %.011 = phi i32 [ 0, %.lr.ph ], [ %14, %6 ]
  %.0910 = phi i32 [ 0, %.lr.ph ], [ %15, %6 ]
  %7 = zext nneg i32 %.0910 to i64
  %8 = getelementptr inbounds i32, ptr %3, i64 %7
  %9 = load i32, ptr %8, align 4, !tbaa !5
  %10 = getelementptr inbounds i32, ptr %4, i64 %7
  %11 = load i32, ptr %10, align 4, !tbaa !5
  %12 = add nsw i32 %11, %9
  %13 = getelementptr inbounds i32, ptr %5, i64 %7
  store i32 %12, ptr %13, align 4, !tbaa !5
  %14 = add i32 %12, %.011
  %15 = add nuw nsw i32 %.0910, 1
  %16 = icmp slt i32 %15, %1
  br i1 %16, label %6, label %._crit_edge.loopexit, !llvm.loop !11

; Exit blocks
._crit_edge.loopexit:                             ; preds = %6
  %.lcssa = phi i32 [ %14, %6 ]
  br label %._crit_edge
Running pass: IndVarSimplifyPass on loop %<unnamed loop> in function sum_1
; *** IR Dump After IndVarSimplifyPass on loop %<unnamed loop> in function sum_1 ***

; Preheader:
.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !9
  %4 = load ptr, ptr @imb, align 8, !tbaa !9
  %5 = load ptr, ptr @imr, align 8, !tbaa !9
  %wide.trip.count = zext i32 %1 to i64
  br label %6

; Loop:
6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !5
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !5
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !5
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp ne i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond, label %6, label %._crit_edge.loopexit, !llvm.loop !11

; Exit blocks
._crit_edge.loopexit:                             ; preds = %6
  %.lcssa = phi i32 [ %13, %6 ]
  br label %._crit_edge
Running pass: LoopDeletionPass on loop %<unnamed loop> in function sum_1
; *** IR Dump After LoopDeletionPass on loop %<unnamed loop> in function sum_1 ***

; Preheader:
.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !9
  %4 = load ptr, ptr @imb, align 8, !tbaa !9
  %5 = load ptr, ptr @imr, align 8, !tbaa !9
  %wide.trip.count = zext i32 %1 to i64
  br label %6

; Loop:
6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !5
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !5
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !5
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp ne i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond, label %6, label %._crit_edge.loopexit, !llvm.loop !11

; Exit blocks
._crit_edge.loopexit:                             ; preds = %6
  %.lcssa = phi i32 [ %13, %6 ]
  br label %._crit_edge
Running pass: LoopFullUnrollPass on loop %<unnamed loop> in function sum_1
; *** IR Dump After LoopFullUnrollPass on loop %<unnamed loop> in function sum_1 ***

; Preheader:
.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !9
  %4 = load ptr, ptr @imb, align 8, !tbaa !9
  %5 = load ptr, ptr @imr, align 8, !tbaa !9
  %wide.trip.count = zext i32 %1 to i64
  br label %6

; Loop:
6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !5
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !5
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !5
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp ne i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond, label %6, label %._crit_edge.loopexit, !llvm.loop !11

; Exit blocks
._crit_edge.loopexit:                             ; preds = %6
  %.lcssa = phi i32 [ %13, %6 ]
  br label %._crit_edge
Running pass: SROAPass on sum_1 (25 instructions)
; *** IR Dump After SROAPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp ne i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond, label %6, label %._crit_edge.loopexit, !llvm.loop !16

._crit_edge.loopexit:                             ; preds = %6
  %.lcssa = phi i32 [ %13, %6 ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %.lcssa, %._crit_edge.loopexit ]
  ret i32 %.0.lcssa
}
Running pass: VectorCombinePass on sum_1 (25 instructions)
; *** IR Dump After VectorCombinePass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp ne i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond, label %6, label %._crit_edge.loopexit, !llvm.loop !16

._crit_edge.loopexit:                             ; preds = %6
  %.lcssa = phi i32 [ %13, %6 ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %.lcssa, %._crit_edge.loopexit ]
  ret i32 %.0.lcssa
}
Running pass: MergedLoadStoreMotionPass on sum_1 (25 instructions)
; *** IR Dump After MergedLoadStoreMotionPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp ne i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond, label %6, label %._crit_edge.loopexit, !llvm.loop !16

._crit_edge.loopexit:                             ; preds = %6
  %.lcssa = phi i32 [ %13, %6 ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %.lcssa, %._crit_edge.loopexit ]
  ret i32 %.0.lcssa
}
Running pass: GVNPass on sum_1 (25 instructions)
Running analysis: MemoryDependenceAnalysis on sum_1
Clearing all analysis results for: <possibly invalidated loop>
Invalidating analysis: ScalarEvolutionAnalysis on sum_1
Invalidating analysis: InnerAnalysisManagerProxy<AnalysisManager<Loop, LoopStandardAnalysisResults&>, Function> on sum_1
Invalidating analysis: MemoryDependenceAnalysis on sum_1
; *** IR Dump After GVNPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp ne i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond, label %6, label %._crit_edge.loopexit, !llvm.loop !16

._crit_edge.loopexit:                             ; preds = %6
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %13, %._crit_edge.loopexit ]
  ret i32 %.0.lcssa
}
Running pass: SCCPPass on sum_1 (24 instructions)
; *** IR Dump After SCCPPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp ne i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond, label %6, label %._crit_edge.loopexit, !llvm.loop !16

._crit_edge.loopexit:                             ; preds = %6
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %13, %._crit_edge.loopexit ]
  ret i32 %.0.lcssa
}
Running pass: BDCEPass on sum_1 (24 instructions)
Running analysis: DemandedBitsAnalysis on sum_1
; *** IR Dump After BDCEPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp ne i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond, label %6, label %._crit_edge.loopexit, !llvm.loop !16

._crit_edge.loopexit:                             ; preds = %6
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %13, %._crit_edge.loopexit ]
  ret i32 %.0.lcssa
}
Running pass: InstCombinePass on sum_1 (24 instructions)
Invalidating analysis: DemandedBitsAnalysis on sum_1
; *** IR Dump After InstCombinePass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge.loopexit, label %6, !llvm.loop !16

._crit_edge.loopexit:                             ; preds = %6
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %13, %._crit_edge.loopexit ]
  ret i32 %.0.lcssa
}
Running pass: JumpThreadingPass on sum_1 (24 instructions)
Running analysis: LazyValueAnalysis on sum_1
Invalidating analysis: LoopAnalysis on sum_1
; *** IR Dump After JumpThreadingPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge, label %6, !llvm.loop !16

._crit_edge:                                      ; preds = %6, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %13, %6 ]
  ret i32 %.0.lcssa
}
Running pass: CorrelatedValuePropagationPass on sum_1 (23 instructions)
Invalidating analysis: LazyValueAnalysis on sum_1
; *** IR Dump After CorrelatedValuePropagationPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge, label %6, !llvm.loop !16

._crit_edge:                                      ; preds = %6, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %13, %6 ]
  ret i32 %.0.lcssa
}
Running pass: ADCEPass on sum_1 (23 instructions)
Running analysis: PostDominatorTreeAnalysis on sum_1
; *** IR Dump After ADCEPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge, label %6, !llvm.loop !16

._crit_edge:                                      ; preds = %6, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %13, %6 ]
  ret i32 %.0.lcssa
}
Running pass: MemCpyOptPass on sum_1 (23 instructions)
Running analysis: MemorySSAAnalysis on sum_1
; *** IR Dump After MemCpyOptPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge, label %6, !llvm.loop !16

._crit_edge:                                      ; preds = %6, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %13, %6 ]
  ret i32 %.0.lcssa
}
Running pass: DSEPass on sum_1 (23 instructions)
Running analysis: LoopAnalysis on sum_1
; *** IR Dump After DSEPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge, label %6, !llvm.loop !16

._crit_edge:                                      ; preds = %6, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %13, %6 ]
  ret i32 %.0.lcssa
}
Running pass: MoveAutoInitPass on sum_1 (23 instructions)
; *** IR Dump After MoveAutoInitPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge, label %6, !llvm.loop !16

._crit_edge:                                      ; preds = %6, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %13, %6 ]
  ret i32 %.0.lcssa
}
Running pass: LoopSimplifyPass on sum_1 (23 instructions)
Invalidating analysis: PostDominatorTreeAnalysis on sum_1
; *** IR Dump After LoopSimplifyPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge.loopexit, label %6, !llvm.loop !16

._crit_edge.loopexit:                             ; preds = %6
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %13, %._crit_edge.loopexit ]
  ret i32 %.0.lcssa
}
Running pass: LCSSAPass on sum_1 (24 instructions)
; *** IR Dump After LCSSAPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge.loopexit, label %6, !llvm.loop !16

._crit_edge.loopexit:                             ; preds = %6
  %.lcssa = phi i32 [ %13, %6 ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %.lcssa, %._crit_edge.loopexit ]
  ret i32 %.0.lcssa
}
Running analysis: ScalarEvolutionAnalysis on sum_1
Running analysis: InnerAnalysisManagerProxy<AnalysisManager<Loop, LoopStandardAnalysisResults&>, Function> on sum_1
Running pass: LICMPass on loop %<unnamed loop> in function sum_1
; *** IR Dump After LICMPass on loop %<unnamed loop> in function sum_1 ***

; Preheader:
.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !9
  %4 = load ptr, ptr @imb, align 8, !tbaa !9
  %5 = load ptr, ptr @imr, align 8, !tbaa !9
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

; Loop:
6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !5
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !5
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !5
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge.loopexit, label %6, !llvm.loop !11

; Exit blocks
._crit_edge.loopexit:                             ; preds = %6
  %.lcssa = phi i32 [ %13, %6 ]
  br label %._crit_edge
Running pass: CoroElidePass on sum_1 (25 instructions)
; *** IR Dump After CoroElidePass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge.loopexit, label %6, !llvm.loop !16

._crit_edge.loopexit:                             ; preds = %6
  %.lcssa = phi i32 [ %13, %6 ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %.lcssa, %._crit_edge.loopexit ]
  ret i32 %.0.lcssa
}
Running pass: SimplifyCFGPass on sum_1 (25 instructions)
Invalidating analysis: DominatorTreeAnalysis on sum_1
Invalidating analysis: BasicAA on sum_1
Invalidating analysis: AAManager on sum_1
Invalidating analysis: MemorySSAAnalysis on sum_1
Invalidating analysis: LoopAnalysis on sum_1
Invalidating analysis: ScalarEvolutionAnalysis on sum_1
Invalidating analysis: InnerAnalysisManagerProxy<AnalysisManager<Loop, LoopStandardAnalysisResults&>, Function> on sum_1
; *** IR Dump After SimplifyCFGPass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge, label %6, !llvm.loop !16

._crit_edge:                                      ; preds = %6, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %13, %6 ]
  ret i32 %.0.lcssa
}
Running pass: InstCombinePass on sum_1 (23 instructions)
Running analysis: DominatorTreeAnalysis on sum_1
Running analysis: AAManager on sum_1
Running analysis: BasicAA on sum_1
; *** IR Dump After InstCombinePass on sum_1 ***
; Function Attrs: nounwind uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge, label %6, !llvm.loop !16

._crit_edge:                                      ; preds = %6, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %13, %6 ]
  ret i32 %.0.lcssa
}
Invalidating analysis: DominatorTreeAnalysis on sum_1
Invalidating analysis: BasicAA on sum_1
Invalidating analysis: AAManager on sum_1
Running pass: PostOrderFunctionAttrsPass on (sum_1) (1 node)
Running analysis: AAManager on sum_1
Running analysis: BasicAA on sum_1
Running analysis: DominatorTreeAnalysis on sum_1
; *** IR Dump After PostOrderFunctionAttrsPass on (sum_1) ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !5
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !9
  %4 = load ptr, ptr @imb, align 8, !tbaa !9
  %5 = load ptr, ptr @imr, align 8, !tbaa !9
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !5
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !5
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !5
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge, label %6, !llvm.loop !11

._crit_edge:                                      ; preds = %6, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %13, %6 ]
  ret i32 %.0.lcssa
}
Running pass: RequireAnalysisPass<ShouldNotRunFunctionPassesAnalysis, Function> on sum_1 (23 instructions)
Running analysis: ShouldNotRunFunctionPassesAnalysis on sum_1
; *** IR Dump After RequireAnalysisPass<ShouldNotRunFunctionPassesAnalysis, Function> on sum_1 ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge, label %6, !llvm.loop !16

._crit_edge:                                      ; preds = %6, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %13, %6 ]
  ret i32 %.0.lcssa
}
Running pass: CoroSplitPass on (sum_1) (1 node)
; *** IR Dump After CoroSplitPass on (sum_1) ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !5
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !9
  %4 = load ptr, ptr @imb, align 8, !tbaa !9
  %5 = load ptr, ptr @imr, align 8, !tbaa !9
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !5
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !5
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !5
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge, label %6, !llvm.loop !11

._crit_edge:                                      ; preds = %6, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %13, %6 ]
  ret i32 %.0.lcssa
}
Invalidating analysis: CallGraphAnalysis on [module]
Running pass: InvalidateAnalysisPass<ShouldNotRunFunctionPassesAnalysis> on Initrand (2 instructions)
Invalidating analysis: ShouldNotRunFunctionPassesAnalysis on Initrand
Running pass: InvalidateAnalysisPass<ShouldNotRunFunctionPassesAnalysis> on Rand (7 instructions)
Invalidating analysis: ShouldNotRunFunctionPassesAnalysis on Rand
Running pass: InvalidateAnalysisPass<ShouldNotRunFunctionPassesAnalysis> on InitArray (24 instructions)
Invalidating analysis: ShouldNotRunFunctionPassesAnalysis on InitArray
Running pass: InvalidateAnalysisPass<ShouldNotRunFunctionPassesAnalysis> on init (56 instructions)
Invalidating analysis: ShouldNotRunFunctionPassesAnalysis on init
Running pass: InvalidateAnalysisPass<ShouldNotRunFunctionPassesAnalysis> on deinit (7 instructions)
Invalidating analysis: ShouldNotRunFunctionPassesAnalysis on deinit
Running pass: InvalidateAnalysisPass<ShouldNotRunFunctionPassesAnalysis> on sum_1 (23 instructions)
Invalidating analysis: ShouldNotRunFunctionPassesAnalysis on sum_1
; *** IR Dump After InvalidateAnalysisPass<ShouldNotRunFunctionPassesAnalysis> on sum_1 ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge, label %6, !llvm.loop !16

._crit_edge:                                      ; preds = %6, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %13, %6 ]
  ret i32 %.0.lcssa
}
Invalidating analysis: InlineAdvisorAnalysis on [module]
Running pass: DeadArgumentEliminationPass on [module]
; *** IR Dump After DeadArgumentEliminationPass on [module] ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge, label %6, !llvm.loop !16

._crit_edge:                                      ; preds = %6, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %13, %6 ]
  ret i32 %.0.lcssa
}
Running pass: CoroCleanupPass on [module]
; *** IR Dump After CoroCleanupPass on [module] ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge, label %6, !llvm.loop !16

._crit_edge:                                      ; preds = %6, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %13, %6 ]
  ret i32 %.0.lcssa
}
Running pass: GlobalOptPass on [module]
; *** IR Dump After GlobalOptPass on [module] ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge, label %6, !llvm.loop !16

._crit_edge:                                      ; preds = %6, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %13, %6 ]
  ret i32 %.0.lcssa
}
Running pass: GlobalDCEPass on [module]
; *** IR Dump After GlobalDCEPass on [module] ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge, label %6, !llvm.loop !16

._crit_edge:                                      ; preds = %6, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %13, %6 ]
  ret i32 %.0.lcssa
}
Running pass: EliminateAvailableExternallyPass on [module]
; *** IR Dump After EliminateAvailableExternallyPass on [module] ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge, label %6, !llvm.loop !16

._crit_edge:                                      ; preds = %6, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %13, %6 ]
  ret i32 %.0.lcssa
}
Running pass: ReversePostOrderFunctionAttrsPass on [module]
; *** IR Dump After ReversePostOrderFunctionAttrsPass on [module] ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge, label %6, !llvm.loop !16

._crit_edge:                                      ; preds = %6, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %13, %6 ]
  ret i32 %.0.lcssa
}
Running pass: RecomputeGlobalsAAPass on [module]
Running analysis: CallGraphAnalysis on [module]
; *** IR Dump After RecomputeGlobalsAAPass on [module] ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge, label %6, !llvm.loop !16

._crit_edge:                                      ; preds = %6, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %13, %6 ]
  ret i32 %.0.lcssa
}
Running pass: Float2IntPass on Initrand (2 instructions)
Running pass: LowerConstantIntrinsicsPass on Initrand (2 instructions)
Running pass: ControlHeightReductionPass on Initrand (2 instructions)
Running pass: LoopSimplifyPass on Initrand (2 instructions)
Running pass: LCSSAPass on Initrand (2 instructions)
Running pass: LoopDistributePass on Initrand (2 instructions)
Running analysis: ScalarEvolutionAnalysis on Initrand
Running analysis: LoopAccessAnalysis on Initrand
Running pass: InjectTLIMappings on Initrand (2 instructions)
Running pass: LoopVectorizePass on Initrand (2 instructions)
Running pass: InferAlignmentPass on Initrand (2 instructions)
Running pass: LoopLoadEliminationPass on Initrand (2 instructions)
Running pass: InstCombinePass on Initrand (2 instructions)
Running pass: SimplifyCFGPass on Initrand (2 instructions)
Running pass: SLPVectorizerPass on Initrand (2 instructions)
Running analysis: DemandedBitsAnalysis on Initrand
Running pass: VectorCombinePass on Initrand (2 instructions)
Running pass: InstCombinePass on Initrand (2 instructions)
Running pass: LoopUnrollPass on Initrand (2 instructions)
Running pass: WarnMissedTransformationsPass on Initrand (2 instructions)
Running pass: SROAPass on Initrand (2 instructions)
Running pass: InferAlignmentPass on Initrand (2 instructions)
Running pass: InstCombinePass on Initrand (2 instructions)
Running pass: LoopSimplifyPass on Initrand (2 instructions)
Running pass: LCSSAPass on Initrand (2 instructions)
Running pass: AlignmentFromAssumptionsPass on Initrand (2 instructions)
Running pass: LoopSinkPass on Initrand (2 instructions)
Running pass: InstSimplifyPass on Initrand (2 instructions)
Running pass: DivRemPairsPass on Initrand (2 instructions)
Running pass: TailCallElimPass on Initrand (2 instructions)
Running pass: SimplifyCFGPass on Initrand (2 instructions)
Invalidating analysis: DominatorTreeAnalysis on Initrand
Invalidating analysis: BasicAA on Initrand
Invalidating analysis: AAManager on Initrand
Invalidating analysis: LoopAnalysis on Initrand
Invalidating analysis: PostDominatorTreeAnalysis on Initrand
Invalidating analysis: BranchProbabilityAnalysis on Initrand
Invalidating analysis: BlockFrequencyAnalysis on Initrand
Invalidating analysis: ScalarEvolutionAnalysis on Initrand
Invalidating analysis: LoopAccessAnalysis on Initrand
Invalidating analysis: DemandedBitsAnalysis on Initrand
Running pass: Float2IntPass on Rand (7 instructions)
Running pass: LowerConstantIntrinsicsPass on Rand (7 instructions)
Running pass: ControlHeightReductionPass on Rand (7 instructions)
Running pass: LoopSimplifyPass on Rand (7 instructions)
Running pass: LCSSAPass on Rand (7 instructions)
Running pass: LoopDistributePass on Rand (7 instructions)
Running analysis: ScalarEvolutionAnalysis on Rand
Running analysis: LoopAccessAnalysis on Rand
Running pass: InjectTLIMappings on Rand (7 instructions)
Running pass: LoopVectorizePass on Rand (7 instructions)
Running pass: InferAlignmentPass on Rand (7 instructions)
Running pass: LoopLoadEliminationPass on Rand (7 instructions)
Running pass: InstCombinePass on Rand (7 instructions)
Running pass: SimplifyCFGPass on Rand (7 instructions)
Running pass: SLPVectorizerPass on Rand (7 instructions)
Running analysis: DemandedBitsAnalysis on Rand
Running pass: VectorCombinePass on Rand (7 instructions)
Running pass: InstCombinePass on Rand (7 instructions)
Running pass: LoopUnrollPass on Rand (7 instructions)
Running pass: WarnMissedTransformationsPass on Rand (7 instructions)
Running pass: SROAPass on Rand (7 instructions)
Running pass: InferAlignmentPass on Rand (7 instructions)
Running pass: InstCombinePass on Rand (7 instructions)
Running pass: LoopSimplifyPass on Rand (7 instructions)
Running pass: LCSSAPass on Rand (7 instructions)
Running pass: AlignmentFromAssumptionsPass on Rand (7 instructions)
Running pass: LoopSinkPass on Rand (7 instructions)
Running pass: InstSimplifyPass on Rand (7 instructions)
Running pass: DivRemPairsPass on Rand (7 instructions)
Running pass: TailCallElimPass on Rand (7 instructions)
Running pass: SimplifyCFGPass on Rand (7 instructions)
Invalidating analysis: DominatorTreeAnalysis on Rand
Invalidating analysis: BasicAA on Rand
Invalidating analysis: AAManager on Rand
Invalidating analysis: LoopAnalysis on Rand
Invalidating analysis: PostDominatorTreeAnalysis on Rand
Invalidating analysis: BranchProbabilityAnalysis on Rand
Invalidating analysis: BlockFrequencyAnalysis on Rand
Invalidating analysis: ScalarEvolutionAnalysis on Rand
Invalidating analysis: LoopAccessAnalysis on Rand
Invalidating analysis: DemandedBitsAnalysis on Rand
Running pass: Float2IntPass on InitArray (24 instructions)
Running pass: LowerConstantIntrinsicsPass on InitArray (24 instructions)
Running pass: ControlHeightReductionPass on InitArray (24 instructions)
Running pass: LoopSimplifyPass on InitArray (24 instructions)
Running pass: LCSSAPass on InitArray (24 instructions)
Running analysis: ScalarEvolutionAnalysis on InitArray
Running analysis: InnerAnalysisManagerProxy<AnalysisManager<Loop, LoopStandardAnalysisResults&>, Function> on InitArray
Running pass: LoopRotatePass on loop %.lr.ph in function InitArray
Running pass: LoopDeletionPass on loop %.lr.ph in function InitArray
Running pass: LoopDistributePass on InitArray (25 instructions)
Running analysis: LoopAccessAnalysis on InitArray
Running pass: InjectTLIMappings on InitArray (25 instructions)
Running pass: LoopVectorizePass on InitArray (25 instructions)
Running analysis: DemandedBitsAnalysis on InitArray
Running pass: InferAlignmentPass on InitArray (25 instructions)
Running pass: LoopLoadEliminationPass on InitArray (25 instructions)
Running pass: InstCombinePass on InitArray (25 instructions)
Clearing all analysis results for: <possibly invalidated loop>
Invalidating analysis: ScalarEvolutionAnalysis on InitArray
Invalidating analysis: InnerAnalysisManagerProxy<AnalysisManager<Loop, LoopStandardAnalysisResults&>, Function> on InitArray
Invalidating analysis: LoopAccessAnalysis on InitArray
Invalidating analysis: DemandedBitsAnalysis on InitArray
Running pass: SimplifyCFGPass on InitArray (24 instructions)
Running pass: SLPVectorizerPass on InitArray (24 instructions)
Running analysis: ScalarEvolutionAnalysis on InitArray
Running analysis: DemandedBitsAnalysis on InitArray
Running pass: VectorCombinePass on InitArray (24 instructions)
Running pass: InstCombinePass on InitArray (24 instructions)
Running pass: LoopUnrollPass on InitArray (24 instructions)
Invalidating analysis: PostDominatorTreeAnalysis on InitArray
Invalidating analysis: BranchProbabilityAnalysis on InitArray
Invalidating analysis: BlockFrequencyAnalysis on InitArray
Invalidating analysis: DemandedBitsAnalysis on InitArray
Running pass: WarnMissedTransformationsPass on InitArray (25 instructions)
Running pass: SROAPass on InitArray (25 instructions)
Running pass: InferAlignmentPass on InitArray (25 instructions)
Running pass: InstCombinePass on InitArray (25 instructions)
Invalidating analysis: ScalarEvolutionAnalysis on InitArray
Running pass: LoopSimplifyPass on InitArray (24 instructions)
Running pass: LCSSAPass on InitArray (24 instructions)
Running analysis: MemorySSAAnalysis on InitArray
Running analysis: ScalarEvolutionAnalysis on InitArray
Running analysis: InnerAnalysisManagerProxy<AnalysisManager<Loop, LoopStandardAnalysisResults&>, Function> on InitArray
Running pass: LICMPass on loop %.lr.ph in function InitArray
Running pass: AlignmentFromAssumptionsPass on InitArray (25 instructions)
Running pass: LoopSinkPass on InitArray (25 instructions)
Running pass: InstSimplifyPass on InitArray (25 instructions)
Invalidating analysis: MemorySSAAnalysis on InitArray
Invalidating analysis: ScalarEvolutionAnalysis on InitArray
Invalidating analysis: InnerAnalysisManagerProxy<AnalysisManager<Loop, LoopStandardAnalysisResults&>, Function> on InitArray
Running pass: DivRemPairsPass on InitArray (24 instructions)
Running pass: TailCallElimPass on InitArray (24 instructions)
Running pass: SimplifyCFGPass on InitArray (24 instructions)
Invalidating analysis: DominatorTreeAnalysis on InitArray
Invalidating analysis: BasicAA on InitArray
Invalidating analysis: AAManager on InitArray
Invalidating analysis: LoopAnalysis on InitArray
Running pass: Float2IntPass on init (56 instructions)
Running pass: LowerConstantIntrinsicsPass on init (56 instructions)
Running pass: ControlHeightReductionPass on init (56 instructions)
Running pass: LoopSimplifyPass on init (56 instructions)
Running analysis: LoopAnalysis on init
Running pass: LCSSAPass on init (57 instructions)
Running analysis: ScalarEvolutionAnalysis on init
Running analysis: InnerAnalysisManagerProxy<AnalysisManager<Loop, LoopStandardAnalysisResults&>, Function> on init
Running pass: LoopRotatePass on loop %.lr.ph.i in function init
Running pass: LoopDeletionPass on loop %.lr.ph.i in function init
Running pass: LoopRotatePass on loop %.lr.ph.i11 in function init
Running pass: LoopDeletionPass on loop %.lr.ph.i11 in function init
Running pass: LoopDistributePass on init (59 instructions)
Running analysis: LoopAccessAnalysis on init
Running pass: InjectTLIMappings on init (59 instructions)
Running pass: LoopVectorizePass on init (59 instructions)
Running analysis: DemandedBitsAnalysis on init
Running pass: InferAlignmentPass on init (59 instructions)
Running pass: LoopLoadEliminationPass on init (59 instructions)
Running pass: InstCombinePass on init (59 instructions)
Clearing all analysis results for: <possibly invalidated loop>
Clearing all analysis results for: <possibly invalidated loop>
Invalidating analysis: ScalarEvolutionAnalysis on init
Invalidating analysis: InnerAnalysisManagerProxy<AnalysisManager<Loop, LoopStandardAnalysisResults&>, Function> on init
Invalidating analysis: LoopAccessAnalysis on init
Invalidating analysis: DemandedBitsAnalysis on init
Running pass: SimplifyCFGPass on init (57 instructions)
Invalidating analysis: DominatorTreeAnalysis on init
Invalidating analysis: BasicAA on init
Invalidating analysis: AAManager on init
Invalidating analysis: LoopAnalysis on init
Running pass: SLPVectorizerPass on init (56 instructions)
Running analysis: ScalarEvolutionAnalysis on init
Running analysis: DominatorTreeAnalysis on init
Running analysis: LoopAnalysis on init
Running analysis: AAManager on init
Running analysis: BasicAA on init
Running analysis: DemandedBitsAnalysis on init
Running pass: VectorCombinePass on init (56 instructions)
Running pass: InstCombinePass on init (56 instructions)
Running pass: LoopUnrollPass on init (56 instructions)
Invalidating analysis: DemandedBitsAnalysis on init
Running pass: WarnMissedTransformationsPass on init (59 instructions)
Running pass: SROAPass on init (59 instructions)
Running pass: InferAlignmentPass on init (59 instructions)
Running pass: InstCombinePass on init (59 instructions)
Invalidating analysis: ScalarEvolutionAnalysis on init
Running pass: LoopSimplifyPass on init (57 instructions)
Running pass: LCSSAPass on init (57 instructions)
Running analysis: MemorySSAAnalysis on init
Running analysis: ScalarEvolutionAnalysis on init
Running analysis: InnerAnalysisManagerProxy<AnalysisManager<Loop, LoopStandardAnalysisResults&>, Function> on init
Running pass: LICMPass on loop %.lr.ph.i in function init
Running pass: LICMPass on loop %.lr.ph.i11 in function init
Running pass: AlignmentFromAssumptionsPass on init (59 instructions)
Running pass: LoopSinkPass on init (59 instructions)
Running pass: InstSimplifyPass on init (59 instructions)
Invalidating analysis: MemorySSAAnalysis on init
Invalidating analysis: ScalarEvolutionAnalysis on init
Invalidating analysis: InnerAnalysisManagerProxy<AnalysisManager<Loop, LoopStandardAnalysisResults&>, Function> on init
Running pass: DivRemPairsPass on init (57 instructions)
Running pass: TailCallElimPass on init (57 instructions)
Running pass: SimplifyCFGPass on init (57 instructions)
Invalidating analysis: DominatorTreeAnalysis on init
Invalidating analysis: LoopAnalysis on init
Invalidating analysis: BasicAA on init
Invalidating analysis: AAManager on init
Running pass: Float2IntPass on deinit (7 instructions)
Running pass: LowerConstantIntrinsicsPass on deinit (7 instructions)
Running pass: ControlHeightReductionPass on deinit (7 instructions)
Running pass: LoopSimplifyPass on deinit (7 instructions)
Running analysis: LoopAnalysis on deinit
Running pass: LCSSAPass on deinit (7 instructions)
Running pass: LoopDistributePass on deinit (7 instructions)
Running analysis: ScalarEvolutionAnalysis on deinit
Running analysis: LoopAccessAnalysis on deinit
Running pass: InjectTLIMappings on deinit (7 instructions)
Running pass: LoopVectorizePass on deinit (7 instructions)
Running pass: InferAlignmentPass on deinit (7 instructions)
Running pass: LoopLoadEliminationPass on deinit (7 instructions)
Running pass: InstCombinePass on deinit (7 instructions)
Running pass: SimplifyCFGPass on deinit (7 instructions)
Running pass: SLPVectorizerPass on deinit (7 instructions)
Running analysis: DemandedBitsAnalysis on deinit
Running pass: VectorCombinePass on deinit (7 instructions)
Running pass: InstCombinePass on deinit (7 instructions)
Running pass: LoopUnrollPass on deinit (7 instructions)
Running pass: WarnMissedTransformationsPass on deinit (7 instructions)
Running pass: SROAPass on deinit (7 instructions)
Running pass: InferAlignmentPass on deinit (7 instructions)
Running pass: InstCombinePass on deinit (7 instructions)
Running pass: LoopSimplifyPass on deinit (7 instructions)
Running pass: LCSSAPass on deinit (7 instructions)
Running pass: AlignmentFromAssumptionsPass on deinit (7 instructions)
Running pass: LoopSinkPass on deinit (7 instructions)
Running pass: InstSimplifyPass on deinit (7 instructions)
Running pass: DivRemPairsPass on deinit (7 instructions)
Running pass: TailCallElimPass on deinit (7 instructions)
Running pass: SimplifyCFGPass on deinit (7 instructions)
Invalidating analysis: DominatorTreeAnalysis on deinit
Invalidating analysis: BasicAA on deinit
Invalidating analysis: AAManager on deinit
Invalidating analysis: LoopAnalysis on deinit
Invalidating analysis: ScalarEvolutionAnalysis on deinit
Invalidating analysis: LoopAccessAnalysis on deinit
Invalidating analysis: DemandedBitsAnalysis on deinit
Running pass: Float2IntPass on sum_1 (23 instructions)
; *** IR Dump After Float2IntPass on sum_1 ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge, label %6, !llvm.loop !16

._crit_edge:                                      ; preds = %6, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %13, %6 ]
  ret i32 %.0.lcssa
}
Running pass: LowerConstantIntrinsicsPass on sum_1 (23 instructions)
; *** IR Dump After LowerConstantIntrinsicsPass on sum_1 ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge, label %6, !llvm.loop !16

._crit_edge:                                      ; preds = %6, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %13, %6 ]
  ret i32 %.0.lcssa
}
Running pass: ControlHeightReductionPass on sum_1 (23 instructions)
; *** IR Dump After ControlHeightReductionPass on sum_1 ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge, label %6, !llvm.loop !16

._crit_edge:                                      ; preds = %6, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %13, %6 ]
  ret i32 %.0.lcssa
}
Running pass: LoopSimplifyPass on sum_1 (23 instructions)
Running analysis: LoopAnalysis on sum_1
; *** IR Dump After LoopSimplifyPass on sum_1 ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge.loopexit, label %6, !llvm.loop !16

._crit_edge.loopexit:                             ; preds = %6
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %13, %._crit_edge.loopexit ]
  ret i32 %.0.lcssa
}
Running pass: LCSSAPass on sum_1 (24 instructions)
; *** IR Dump After LCSSAPass on sum_1 ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge.loopexit, label %6, !llvm.loop !16

._crit_edge.loopexit:                             ; preds = %6
  %.lcssa = phi i32 [ %13, %6 ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %.lcssa, %._crit_edge.loopexit ]
  ret i32 %.0.lcssa
}
Running analysis: ScalarEvolutionAnalysis on sum_1
Running analysis: InnerAnalysisManagerProxy<AnalysisManager<Loop, LoopStandardAnalysisResults&>, Function> on sum_1
Running pass: LoopRotatePass on loop %<unnamed loop> in function sum_1
; *** IR Dump After LoopRotatePass on loop %<unnamed loop> in function sum_1 ***

; Preheader:
.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !9
  %4 = load ptr, ptr @imb, align 8, !tbaa !9
  %5 = load ptr, ptr @imr, align 8, !tbaa !9
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

; Loop:
6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !5
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !5
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !5
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge.loopexit, label %6, !llvm.loop !11

; Exit blocks
._crit_edge.loopexit:                             ; preds = %6
  %.lcssa = phi i32 [ %13, %6 ]
  br label %._crit_edge
Running pass: LoopDeletionPass on loop %<unnamed loop> in function sum_1
; *** IR Dump After LoopDeletionPass on loop %<unnamed loop> in function sum_1 ***

; Preheader:
.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !9
  %4 = load ptr, ptr @imb, align 8, !tbaa !9
  %5 = load ptr, ptr @imr, align 8, !tbaa !9
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

; Loop:
6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !5
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !5
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !5
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge.loopexit, label %6, !llvm.loop !11

; Exit blocks
._crit_edge.loopexit:                             ; preds = %6
  %.lcssa = phi i32 [ %13, %6 ]
  br label %._crit_edge
Running pass: LoopDistributePass on sum_1 (25 instructions)
Running analysis: LoopAccessAnalysis on sum_1
; *** IR Dump After LoopDistributePass on sum_1 ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge.loopexit, label %6, !llvm.loop !16

._crit_edge.loopexit:                             ; preds = %6
  %.lcssa = phi i32 [ %13, %6 ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %.lcssa, %._crit_edge.loopexit ]
  ret i32 %.0.lcssa
}
Running pass: InjectTLIMappings on sum_1 (25 instructions)
; *** IR Dump After InjectTLIMappings on sum_1 ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  br label %6

6:                                                ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %.011 = phi i32 [ 0, %.lr.ph ], [ %13, %6 ]
  %7 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %8 = load i32, ptr %7, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %10 = load i32, ptr %9, align 4, !tbaa !9
  %11 = add nsw i32 %10, %8
  %12 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %11, ptr %12, align 4, !tbaa !9
  %13 = add i32 %11, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge.loopexit, label %6, !llvm.loop !16

._crit_edge.loopexit:                             ; preds = %6
  %.lcssa = phi i32 [ %13, %6 ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %.lcssa, %._crit_edge.loopexit ]
  ret i32 %.0.lcssa
}
Running pass: LoopVectorizePass on sum_1 (25 instructions)
Running analysis: DemandedBitsAnalysis on sum_1
Running analysis: ShouldRunExtraVectorPasses on sum_1
Clearing all analysis results for: <possibly invalidated loop>
Invalidating analysis: InnerAnalysisManagerProxy<AnalysisManager<Loop, LoopStandardAnalysisResults&>, Function> on sum_1
Invalidating analysis: DemandedBitsAnalysis on sum_1
; *** IR Dump After LoopVectorizePass on sum_1 ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  %min.iters.check = icmp ult i64 %wide.trip.count, 8
  br i1 %min.iters.check, label %scalar.ph, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %n.mod.vf = urem i64 %wide.trip.count, 8
  %n.vec = sub i64 %wide.trip.count, %n.mod.vf
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %vec.phi = phi <8 x i32> [ zeroinitializer, %vector.ph ], [ %14, %vector.body ]
  %6 = add i64 %index, 0
  %7 = getelementptr inbounds i32, ptr %3, i64 %6
  %8 = getelementptr inbounds i32, ptr %7, i32 0
  %wide.load = load <8 x i32>, ptr %8, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %6
  %10 = getelementptr inbounds i32, ptr %9, i32 0
  %wide.load13 = load <8 x i32>, ptr %10, align 4, !tbaa !9
  %11 = add nsw <8 x i32> %wide.load13, %wide.load
  %12 = getelementptr inbounds i32, ptr %5, i64 %6
  %13 = getelementptr inbounds i32, ptr %12, i32 0
  store <8 x i32> %11, ptr %13, align 4, !tbaa !9
  %14 = add <8 x i32> %11, %vec.phi
  %index.next = add nuw i64 %index, 8
  %15 = icmp eq i64 %index.next, %n.vec
  br i1 %15, label %middle.block, label %vector.body, !llvm.loop !16

middle.block:                                     ; preds = %vector.body
  %16 = call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %14)
  %cmp.n = icmp eq i64 %wide.trip.count, %n.vec
  br i1 %cmp.n, label %._crit_edge.loopexit, label %scalar.ph

scalar.ph:                                        ; preds = %middle.block, %.lr.ph
  %bc.resume.val = phi i64 [ %n.vec, %middle.block ], [ 0, %.lr.ph ]
  %bc.merge.rdx = phi i32 [ %16, %middle.block ], [ 0, %.lr.ph ]
  br label %17

17:                                               ; preds = %scalar.ph, %17
  %indvars.iv = phi i64 [ %bc.resume.val, %scalar.ph ], [ %indvars.iv.next, %17 ]
  %.011 = phi i32 [ %bc.merge.rdx, %scalar.ph ], [ %24, %17 ]
  %18 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %19 = load i32, ptr %18, align 4, !tbaa !9
  %20 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %21 = load i32, ptr %20, align 4, !tbaa !9
  %22 = add nsw i32 %21, %19
  %23 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %22, ptr %23, align 4, !tbaa !9
  %24 = add i32 %22, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge.loopexit, label %17, !llvm.loop !19

._crit_edge.loopexit:                             ; preds = %middle.block, %17
  %.lcssa = phi i32 [ %24, %17 ], [ %16, %middle.block ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %.lcssa, %._crit_edge.loopexit ]
  ret i32 %.0.lcssa
}
Running pass: InferAlignmentPass on sum_1 (52 instructions)
; *** IR Dump After InferAlignmentPass on sum_1 ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  %min.iters.check = icmp ult i64 %wide.trip.count, 8
  br i1 %min.iters.check, label %scalar.ph, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %n.mod.vf = urem i64 %wide.trip.count, 8
  %n.vec = sub i64 %wide.trip.count, %n.mod.vf
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %vec.phi = phi <8 x i32> [ zeroinitializer, %vector.ph ], [ %14, %vector.body ]
  %6 = add i64 %index, 0
  %7 = getelementptr inbounds i32, ptr %3, i64 %6
  %8 = getelementptr inbounds i32, ptr %7, i32 0
  %wide.load = load <8 x i32>, ptr %8, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %6
  %10 = getelementptr inbounds i32, ptr %9, i32 0
  %wide.load13 = load <8 x i32>, ptr %10, align 4, !tbaa !9
  %11 = add nsw <8 x i32> %wide.load13, %wide.load
  %12 = getelementptr inbounds i32, ptr %5, i64 %6
  %13 = getelementptr inbounds i32, ptr %12, i32 0
  store <8 x i32> %11, ptr %13, align 4, !tbaa !9
  %14 = add <8 x i32> %11, %vec.phi
  %index.next = add nuw i64 %index, 8
  %15 = icmp eq i64 %index.next, %n.vec
  br i1 %15, label %middle.block, label %vector.body, !llvm.loop !16

middle.block:                                     ; preds = %vector.body
  %16 = call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %14)
  %cmp.n = icmp eq i64 %wide.trip.count, %n.vec
  br i1 %cmp.n, label %._crit_edge.loopexit, label %scalar.ph

scalar.ph:                                        ; preds = %middle.block, %.lr.ph
  %bc.resume.val = phi i64 [ %n.vec, %middle.block ], [ 0, %.lr.ph ]
  %bc.merge.rdx = phi i32 [ %16, %middle.block ], [ 0, %.lr.ph ]
  br label %17

17:                                               ; preds = %scalar.ph, %17
  %indvars.iv = phi i64 [ %bc.resume.val, %scalar.ph ], [ %indvars.iv.next, %17 ]
  %.011 = phi i32 [ %bc.merge.rdx, %scalar.ph ], [ %24, %17 ]
  %18 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %19 = load i32, ptr %18, align 4, !tbaa !9
  %20 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %21 = load i32, ptr %20, align 4, !tbaa !9
  %22 = add nsw i32 %21, %19
  %23 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %22, ptr %23, align 4, !tbaa !9
  %24 = add i32 %22, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge.loopexit, label %17, !llvm.loop !19

._crit_edge.loopexit:                             ; preds = %middle.block, %17
  %.lcssa = phi i32 [ %24, %17 ], [ %16, %middle.block ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %.lcssa, %._crit_edge.loopexit ]
  ret i32 %.0.lcssa
}
Running pass: LoopLoadEliminationPass on sum_1 (52 instructions)
Invalidating analysis: ScalarEvolutionAnalysis on sum_1
Invalidating analysis: LoopAccessAnalysis on sum_1
; *** IR Dump After LoopLoadEliminationPass on sum_1 ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  %min.iters.check = icmp ult i64 %wide.trip.count, 8
  br i1 %min.iters.check, label %scalar.ph, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %n.mod.vf = urem i64 %wide.trip.count, 8
  %n.vec = sub i64 %wide.trip.count, %n.mod.vf
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %vec.phi = phi <8 x i32> [ zeroinitializer, %vector.ph ], [ %14, %vector.body ]
  %6 = add i64 %index, 0
  %7 = getelementptr inbounds i32, ptr %3, i64 %6
  %8 = getelementptr inbounds i32, ptr %7, i32 0
  %wide.load = load <8 x i32>, ptr %8, align 4, !tbaa !9
  %9 = getelementptr inbounds i32, ptr %4, i64 %6
  %10 = getelementptr inbounds i32, ptr %9, i32 0
  %wide.load13 = load <8 x i32>, ptr %10, align 4, !tbaa !9
  %11 = add nsw <8 x i32> %wide.load13, %wide.load
  %12 = getelementptr inbounds i32, ptr %5, i64 %6
  %13 = getelementptr inbounds i32, ptr %12, i32 0
  store <8 x i32> %11, ptr %13, align 4, !tbaa !9
  %14 = add <8 x i32> %11, %vec.phi
  %index.next = add nuw i64 %index, 8
  %15 = icmp eq i64 %index.next, %n.vec
  br i1 %15, label %middle.block, label %vector.body, !llvm.loop !16

middle.block:                                     ; preds = %vector.body
  %16 = call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %14)
  %cmp.n = icmp eq i64 %wide.trip.count, %n.vec
  br i1 %cmp.n, label %._crit_edge.loopexit, label %scalar.ph

scalar.ph:                                        ; preds = %middle.block, %.lr.ph
  %bc.resume.val = phi i64 [ %n.vec, %middle.block ], [ 0, %.lr.ph ]
  %bc.merge.rdx = phi i32 [ %16, %middle.block ], [ 0, %.lr.ph ]
  br label %17

17:                                               ; preds = %scalar.ph, %17
  %indvars.iv = phi i64 [ %bc.resume.val, %scalar.ph ], [ %indvars.iv.next, %17 ]
  %.011 = phi i32 [ %bc.merge.rdx, %scalar.ph ], [ %24, %17 ]
  %18 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %19 = load i32, ptr %18, align 4, !tbaa !9
  %20 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %21 = load i32, ptr %20, align 4, !tbaa !9
  %22 = add nsw i32 %21, %19
  %23 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %22, ptr %23, align 4, !tbaa !9
  %24 = add i32 %22, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge.loopexit.loopexit, label %17, !llvm.loop !19

._crit_edge.loopexit.loopexit:                    ; preds = %17
  br label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %._crit_edge.loopexit.loopexit, %middle.block
  %.lcssa = phi i32 [ %16, %middle.block ], [ %24, %._crit_edge.loopexit.loopexit ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %.lcssa, %._crit_edge.loopexit ]
  ret i32 %.0.lcssa
}
Running pass: InstCombinePass on sum_1 (53 instructions)
; *** IR Dump After InstCombinePass on sum_1 ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  %min.iters.check = icmp ult i32 %1, 8
  br i1 %min.iters.check, label %scalar.ph, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %n.vec = and i64 %wide.trip.count, 2147483640
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %vec.phi = phi <8 x i32> [ zeroinitializer, %vector.ph ], [ %10, %vector.body ]
  %6 = getelementptr inbounds i32, ptr %3, i64 %index
  %wide.load = load <8 x i32>, ptr %6, align 4, !tbaa !9
  %7 = getelementptr inbounds i32, ptr %4, i64 %index
  %wide.load13 = load <8 x i32>, ptr %7, align 4, !tbaa !9
  %8 = add nsw <8 x i32> %wide.load13, %wide.load
  %9 = getelementptr inbounds i32, ptr %5, i64 %index
  store <8 x i32> %8, ptr %9, align 4, !tbaa !9
  %10 = add <8 x i32> %8, %vec.phi
  %index.next = add nuw i64 %index, 8
  %11 = icmp eq i64 %index.next, %n.vec
  br i1 %11, label %middle.block, label %vector.body, !llvm.loop !16

middle.block:                                     ; preds = %vector.body
  %12 = call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %10)
  %cmp.n = icmp eq i64 %n.vec, %wide.trip.count
  br i1 %cmp.n, label %._crit_edge.loopexit, label %scalar.ph

scalar.ph:                                        ; preds = %middle.block, %.lr.ph
  %bc.resume.val = phi i64 [ %n.vec, %middle.block ], [ 0, %.lr.ph ]
  %bc.merge.rdx = phi i32 [ %12, %middle.block ], [ 0, %.lr.ph ]
  br label %13

13:                                               ; preds = %scalar.ph, %13
  %indvars.iv = phi i64 [ %bc.resume.val, %scalar.ph ], [ %indvars.iv.next, %13 ]
  %.011 = phi i32 [ %bc.merge.rdx, %scalar.ph ], [ %20, %13 ]
  %14 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %15 = load i32, ptr %14, align 4, !tbaa !9
  %16 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %17 = load i32, ptr %16, align 4, !tbaa !9
  %18 = add nsw i32 %17, %15
  %19 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %18, ptr %19, align 4, !tbaa !9
  %20 = add i32 %18, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge.loopexit.loopexit, label %13, !llvm.loop !19

._crit_edge.loopexit.loopexit:                    ; preds = %13
  br label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %._crit_edge.loopexit.loopexit, %middle.block
  %.lcssa = phi i32 [ %12, %middle.block ], [ %20, %._crit_edge.loopexit.loopexit ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %.lcssa, %._crit_edge.loopexit ]
  ret i32 %.0.lcssa
}
Running pass: SimplifyCFGPass on sum_1 (48 instructions)
Invalidating analysis: DominatorTreeAnalysis on sum_1
Invalidating analysis: BasicAA on sum_1
Invalidating analysis: AAManager on sum_1
Invalidating analysis: LoopAnalysis on sum_1
; *** IR Dump After SimplifyCFGPass on sum_1 ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  %min.iters.check = icmp ult i32 %1, 8
  br i1 %min.iters.check, label %scalar.ph, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %n.vec = and i64 %wide.trip.count, 2147483640
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %vec.phi = phi <8 x i32> [ zeroinitializer, %vector.ph ], [ %10, %vector.body ]
  %6 = getelementptr inbounds i32, ptr %3, i64 %index
  %wide.load = load <8 x i32>, ptr %6, align 4, !tbaa !9
  %7 = getelementptr inbounds i32, ptr %4, i64 %index
  %wide.load13 = load <8 x i32>, ptr %7, align 4, !tbaa !9
  %8 = add nsw <8 x i32> %wide.load13, %wide.load
  %9 = getelementptr inbounds i32, ptr %5, i64 %index
  store <8 x i32> %8, ptr %9, align 4, !tbaa !9
  %10 = add <8 x i32> %8, %vec.phi
  %index.next = add nuw i64 %index, 8
  %11 = icmp eq i64 %index.next, %n.vec
  br i1 %11, label %middle.block, label %vector.body, !llvm.loop !16

middle.block:                                     ; preds = %vector.body
  %12 = call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %10)
  %cmp.n = icmp eq i64 %n.vec, %wide.trip.count
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph

scalar.ph:                                        ; preds = %.lr.ph, %middle.block, %scalar.ph
  %indvars.iv = phi i64 [ %indvars.iv.next, %scalar.ph ], [ %n.vec, %middle.block ], [ 0, %.lr.ph ]
  %.011 = phi i32 [ %19, %scalar.ph ], [ %12, %middle.block ], [ 0, %.lr.ph ]
  %13 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %14 = load i32, ptr %13, align 4, !tbaa !9
  %15 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %16 = load i32, ptr %15, align 4, !tbaa !9
  %17 = add nsw i32 %16, %14
  %18 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %17, ptr %18, align 4, !tbaa !9
  %19 = add i32 %17, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge, label %scalar.ph, !llvm.loop !19

._crit_edge:                                      ; preds = %middle.block, %scalar.ph, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %12, %middle.block ], [ %19, %scalar.ph ]
  ret i32 %.0.lcssa
}
Running pass: SLPVectorizerPass on sum_1 (42 instructions)
Running analysis: ScalarEvolutionAnalysis on sum_1
Running analysis: DominatorTreeAnalysis on sum_1
Running analysis: LoopAnalysis on sum_1
Running analysis: AAManager on sum_1
Running analysis: BasicAA on sum_1
Running analysis: DemandedBitsAnalysis on sum_1
; *** IR Dump After SLPVectorizerPass on sum_1 ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  %min.iters.check = icmp ult i32 %1, 8
  br i1 %min.iters.check, label %scalar.ph, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %n.vec = and i64 %wide.trip.count, 2147483640
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %vec.phi = phi <8 x i32> [ zeroinitializer, %vector.ph ], [ %10, %vector.body ]
  %6 = getelementptr inbounds i32, ptr %3, i64 %index
  %wide.load = load <8 x i32>, ptr %6, align 4, !tbaa !9
  %7 = getelementptr inbounds i32, ptr %4, i64 %index
  %wide.load13 = load <8 x i32>, ptr %7, align 4, !tbaa !9
  %8 = add nsw <8 x i32> %wide.load13, %wide.load
  %9 = getelementptr inbounds i32, ptr %5, i64 %index
  store <8 x i32> %8, ptr %9, align 4, !tbaa !9
  %10 = add <8 x i32> %8, %vec.phi
  %index.next = add nuw i64 %index, 8
  %11 = icmp eq i64 %index.next, %n.vec
  br i1 %11, label %middle.block, label %vector.body, !llvm.loop !16

middle.block:                                     ; preds = %vector.body
  %12 = call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %10)
  %cmp.n = icmp eq i64 %n.vec, %wide.trip.count
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph

scalar.ph:                                        ; preds = %.lr.ph, %middle.block, %scalar.ph
  %indvars.iv = phi i64 [ %indvars.iv.next, %scalar.ph ], [ %n.vec, %middle.block ], [ 0, %.lr.ph ]
  %.011 = phi i32 [ %19, %scalar.ph ], [ %12, %middle.block ], [ 0, %.lr.ph ]
  %13 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %14 = load i32, ptr %13, align 4, !tbaa !9
  %15 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %16 = load i32, ptr %15, align 4, !tbaa !9
  %17 = add nsw i32 %16, %14
  %18 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %17, ptr %18, align 4, !tbaa !9
  %19 = add i32 %17, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge, label %scalar.ph, !llvm.loop !19

._crit_edge:                                      ; preds = %middle.block, %scalar.ph, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %12, %middle.block ], [ %19, %scalar.ph ]
  ret i32 %.0.lcssa
}
Running pass: VectorCombinePass on sum_1 (42 instructions)
; *** IR Dump After VectorCombinePass on sum_1 ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  %min.iters.check = icmp ult i32 %1, 8
  br i1 %min.iters.check, label %scalar.ph, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %n.vec = and i64 %wide.trip.count, 2147483640
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %vec.phi = phi <8 x i32> [ zeroinitializer, %vector.ph ], [ %10, %vector.body ]
  %6 = getelementptr inbounds i32, ptr %3, i64 %index
  %wide.load = load <8 x i32>, ptr %6, align 4, !tbaa !9
  %7 = getelementptr inbounds i32, ptr %4, i64 %index
  %wide.load13 = load <8 x i32>, ptr %7, align 4, !tbaa !9
  %8 = add nsw <8 x i32> %wide.load13, %wide.load
  %9 = getelementptr inbounds i32, ptr %5, i64 %index
  store <8 x i32> %8, ptr %9, align 4, !tbaa !9
  %10 = add <8 x i32> %8, %vec.phi
  %index.next = add nuw i64 %index, 8
  %11 = icmp eq i64 %index.next, %n.vec
  br i1 %11, label %middle.block, label %vector.body, !llvm.loop !16

middle.block:                                     ; preds = %vector.body
  %12 = call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %10)
  %cmp.n = icmp eq i64 %n.vec, %wide.trip.count
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph

scalar.ph:                                        ; preds = %.lr.ph, %middle.block, %scalar.ph
  %indvars.iv = phi i64 [ %indvars.iv.next, %scalar.ph ], [ %n.vec, %middle.block ], [ 0, %.lr.ph ]
  %.011 = phi i32 [ %19, %scalar.ph ], [ %12, %middle.block ], [ 0, %.lr.ph ]
  %13 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %14 = load i32, ptr %13, align 4, !tbaa !9
  %15 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %16 = load i32, ptr %15, align 4, !tbaa !9
  %17 = add nsw i32 %16, %14
  %18 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %17, ptr %18, align 4, !tbaa !9
  %19 = add i32 %17, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge, label %scalar.ph, !llvm.loop !19

._crit_edge:                                      ; preds = %middle.block, %scalar.ph, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %12, %middle.block ], [ %19, %scalar.ph ]
  ret i32 %.0.lcssa
}
Running pass: InstCombinePass on sum_1 (42 instructions)
; *** IR Dump After InstCombinePass on sum_1 ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  %min.iters.check = icmp ult i32 %1, 8
  br i1 %min.iters.check, label %scalar.ph, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %n.vec = and i64 %wide.trip.count, 2147483640
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %vec.phi = phi <8 x i32> [ zeroinitializer, %vector.ph ], [ %10, %vector.body ]
  %6 = getelementptr inbounds i32, ptr %3, i64 %index
  %wide.load = load <8 x i32>, ptr %6, align 4, !tbaa !9
  %7 = getelementptr inbounds i32, ptr %4, i64 %index
  %wide.load13 = load <8 x i32>, ptr %7, align 4, !tbaa !9
  %8 = add nsw <8 x i32> %wide.load13, %wide.load
  %9 = getelementptr inbounds i32, ptr %5, i64 %index
  store <8 x i32> %8, ptr %9, align 4, !tbaa !9
  %10 = add <8 x i32> %8, %vec.phi
  %index.next = add nuw i64 %index, 8
  %11 = icmp eq i64 %index.next, %n.vec
  br i1 %11, label %middle.block, label %vector.body, !llvm.loop !16

middle.block:                                     ; preds = %vector.body
  %12 = call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %10)
  %cmp.n = icmp eq i64 %n.vec, %wide.trip.count
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph

scalar.ph:                                        ; preds = %.lr.ph, %middle.block, %scalar.ph
  %indvars.iv = phi i64 [ %indvars.iv.next, %scalar.ph ], [ %n.vec, %middle.block ], [ 0, %.lr.ph ]
  %.011 = phi i32 [ %19, %scalar.ph ], [ %12, %middle.block ], [ 0, %.lr.ph ]
  %13 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %14 = load i32, ptr %13, align 4, !tbaa !9
  %15 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %16 = load i32, ptr %15, align 4, !tbaa !9
  %17 = add nsw i32 %16, %14
  %18 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %17, ptr %18, align 4, !tbaa !9
  %19 = add i32 %17, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge, label %scalar.ph, !llvm.loop !19

._crit_edge:                                      ; preds = %middle.block, %scalar.ph, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %12, %middle.block ], [ %19, %scalar.ph ]
  ret i32 %.0.lcssa
}
Running pass: LoopUnrollPass on sum_1 (42 instructions)
Invalidating analysis: DemandedBitsAnalysis on sum_1
; *** IR Dump After LoopUnrollPass on sum_1 ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  %min.iters.check = icmp ult i32 %1, 8
  br i1 %min.iters.check, label %scalar.ph.preheader, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %n.vec = and i64 %wide.trip.count, 2147483640
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %vec.phi = phi <8 x i32> [ zeroinitializer, %vector.ph ], [ %10, %vector.body ]
  %6 = getelementptr inbounds i32, ptr %3, i64 %index
  %wide.load = load <8 x i32>, ptr %6, align 4, !tbaa !9
  %7 = getelementptr inbounds i32, ptr %4, i64 %index
  %wide.load13 = load <8 x i32>, ptr %7, align 4, !tbaa !9
  %8 = add nsw <8 x i32> %wide.load13, %wide.load
  %9 = getelementptr inbounds i32, ptr %5, i64 %index
  store <8 x i32> %8, ptr %9, align 4, !tbaa !9
  %10 = add <8 x i32> %8, %vec.phi
  %index.next = add nuw i64 %index, 8
  %11 = icmp eq i64 %index.next, %n.vec
  br i1 %11, label %middle.block, label %vector.body, !llvm.loop !16

middle.block:                                     ; preds = %vector.body
  %.lcssa14 = phi <8 x i32> [ %10, %vector.body ]
  %12 = call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %.lcssa14)
  %cmp.n = icmp eq i64 %n.vec, %wide.trip.count
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph.preheader

scalar.ph.preheader:                              ; preds = %middle.block, %.lr.ph
  %indvars.iv.ph = phi i64 [ 0, %.lr.ph ], [ %n.vec, %middle.block ]
  %.011.ph = phi i32 [ 0, %.lr.ph ], [ %12, %middle.block ]
  br label %scalar.ph

scalar.ph:                                        ; preds = %scalar.ph.preheader, %scalar.ph
  %indvars.iv = phi i64 [ %indvars.iv.next, %scalar.ph ], [ %indvars.iv.ph, %scalar.ph.preheader ]
  %.011 = phi i32 [ %19, %scalar.ph ], [ %.011.ph, %scalar.ph.preheader ]
  %13 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %14 = load i32, ptr %13, align 4, !tbaa !9
  %15 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %16 = load i32, ptr %15, align 4, !tbaa !9
  %17 = add nsw i32 %16, %14
  %18 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %17, ptr %18, align 4, !tbaa !9
  %19 = add i32 %17, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge.loopexit, label %scalar.ph, !llvm.loop !19

._crit_edge.loopexit:                             ; preds = %scalar.ph
  %.lcssa = phi i32 [ %19, %scalar.ph ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %middle.block, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %12, %middle.block ], [ %.lcssa, %._crit_edge.loopexit ]
  ret i32 %.0.lcssa
}
Running pass: WarnMissedTransformationsPass on sum_1 (48 instructions)
; *** IR Dump After WarnMissedTransformationsPass on sum_1 ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  %min.iters.check = icmp ult i32 %1, 8
  br i1 %min.iters.check, label %scalar.ph.preheader, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %n.vec = and i64 %wide.trip.count, 2147483640
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %vec.phi = phi <8 x i32> [ zeroinitializer, %vector.ph ], [ %10, %vector.body ]
  %6 = getelementptr inbounds i32, ptr %3, i64 %index
  %wide.load = load <8 x i32>, ptr %6, align 4, !tbaa !9
  %7 = getelementptr inbounds i32, ptr %4, i64 %index
  %wide.load13 = load <8 x i32>, ptr %7, align 4, !tbaa !9
  %8 = add nsw <8 x i32> %wide.load13, %wide.load
  %9 = getelementptr inbounds i32, ptr %5, i64 %index
  store <8 x i32> %8, ptr %9, align 4, !tbaa !9
  %10 = add <8 x i32> %8, %vec.phi
  %index.next = add nuw i64 %index, 8
  %11 = icmp eq i64 %index.next, %n.vec
  br i1 %11, label %middle.block, label %vector.body, !llvm.loop !16

middle.block:                                     ; preds = %vector.body
  %.lcssa14 = phi <8 x i32> [ %10, %vector.body ]
  %12 = call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %.lcssa14)
  %cmp.n = icmp eq i64 %n.vec, %wide.trip.count
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph.preheader

scalar.ph.preheader:                              ; preds = %middle.block, %.lr.ph
  %indvars.iv.ph = phi i64 [ 0, %.lr.ph ], [ %n.vec, %middle.block ]
  %.011.ph = phi i32 [ 0, %.lr.ph ], [ %12, %middle.block ]
  br label %scalar.ph

scalar.ph:                                        ; preds = %scalar.ph.preheader, %scalar.ph
  %indvars.iv = phi i64 [ %indvars.iv.next, %scalar.ph ], [ %indvars.iv.ph, %scalar.ph.preheader ]
  %.011 = phi i32 [ %19, %scalar.ph ], [ %.011.ph, %scalar.ph.preheader ]
  %13 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %14 = load i32, ptr %13, align 4, !tbaa !9
  %15 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %16 = load i32, ptr %15, align 4, !tbaa !9
  %17 = add nsw i32 %16, %14
  %18 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %17, ptr %18, align 4, !tbaa !9
  %19 = add i32 %17, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge.loopexit, label %scalar.ph, !llvm.loop !19

._crit_edge.loopexit:                             ; preds = %scalar.ph
  %.lcssa = phi i32 [ %19, %scalar.ph ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %middle.block, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %12, %middle.block ], [ %.lcssa, %._crit_edge.loopexit ]
  ret i32 %.0.lcssa
}
Running pass: SROAPass on sum_1 (48 instructions)
; *** IR Dump After SROAPass on sum_1 ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  %min.iters.check = icmp ult i32 %1, 8
  br i1 %min.iters.check, label %scalar.ph.preheader, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %n.vec = and i64 %wide.trip.count, 2147483640
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %vec.phi = phi <8 x i32> [ zeroinitializer, %vector.ph ], [ %10, %vector.body ]
  %6 = getelementptr inbounds i32, ptr %3, i64 %index
  %wide.load = load <8 x i32>, ptr %6, align 4, !tbaa !9
  %7 = getelementptr inbounds i32, ptr %4, i64 %index
  %wide.load13 = load <8 x i32>, ptr %7, align 4, !tbaa !9
  %8 = add nsw <8 x i32> %wide.load13, %wide.load
  %9 = getelementptr inbounds i32, ptr %5, i64 %index
  store <8 x i32> %8, ptr %9, align 4, !tbaa !9
  %10 = add <8 x i32> %8, %vec.phi
  %index.next = add nuw i64 %index, 8
  %11 = icmp eq i64 %index.next, %n.vec
  br i1 %11, label %middle.block, label %vector.body, !llvm.loop !16

middle.block:                                     ; preds = %vector.body
  %.lcssa14 = phi <8 x i32> [ %10, %vector.body ]
  %12 = call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %.lcssa14)
  %cmp.n = icmp eq i64 %n.vec, %wide.trip.count
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph.preheader

scalar.ph.preheader:                              ; preds = %middle.block, %.lr.ph
  %indvars.iv.ph = phi i64 [ 0, %.lr.ph ], [ %n.vec, %middle.block ]
  %.011.ph = phi i32 [ 0, %.lr.ph ], [ %12, %middle.block ]
  br label %scalar.ph

scalar.ph:                                        ; preds = %scalar.ph.preheader, %scalar.ph
  %indvars.iv = phi i64 [ %indvars.iv.next, %scalar.ph ], [ %indvars.iv.ph, %scalar.ph.preheader ]
  %.011 = phi i32 [ %19, %scalar.ph ], [ %.011.ph, %scalar.ph.preheader ]
  %13 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %14 = load i32, ptr %13, align 4, !tbaa !9
  %15 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %16 = load i32, ptr %15, align 4, !tbaa !9
  %17 = add nsw i32 %16, %14
  %18 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %17, ptr %18, align 4, !tbaa !9
  %19 = add i32 %17, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge.loopexit, label %scalar.ph, !llvm.loop !19

._crit_edge.loopexit:                             ; preds = %scalar.ph
  %.lcssa = phi i32 [ %19, %scalar.ph ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %middle.block, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %12, %middle.block ], [ %.lcssa, %._crit_edge.loopexit ]
  ret i32 %.0.lcssa
}
Running pass: InferAlignmentPass on sum_1 (48 instructions)
; *** IR Dump After InferAlignmentPass on sum_1 ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  %min.iters.check = icmp ult i32 %1, 8
  br i1 %min.iters.check, label %scalar.ph.preheader, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %n.vec = and i64 %wide.trip.count, 2147483640
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %vec.phi = phi <8 x i32> [ zeroinitializer, %vector.ph ], [ %10, %vector.body ]
  %6 = getelementptr inbounds i32, ptr %3, i64 %index
  %wide.load = load <8 x i32>, ptr %6, align 4, !tbaa !9
  %7 = getelementptr inbounds i32, ptr %4, i64 %index
  %wide.load13 = load <8 x i32>, ptr %7, align 4, !tbaa !9
  %8 = add nsw <8 x i32> %wide.load13, %wide.load
  %9 = getelementptr inbounds i32, ptr %5, i64 %index
  store <8 x i32> %8, ptr %9, align 4, !tbaa !9
  %10 = add <8 x i32> %8, %vec.phi
  %index.next = add nuw i64 %index, 8
  %11 = icmp eq i64 %index.next, %n.vec
  br i1 %11, label %middle.block, label %vector.body, !llvm.loop !16

middle.block:                                     ; preds = %vector.body
  %.lcssa14 = phi <8 x i32> [ %10, %vector.body ]
  %12 = call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %.lcssa14)
  %cmp.n = icmp eq i64 %n.vec, %wide.trip.count
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph.preheader

scalar.ph.preheader:                              ; preds = %middle.block, %.lr.ph
  %indvars.iv.ph = phi i64 [ 0, %.lr.ph ], [ %n.vec, %middle.block ]
  %.011.ph = phi i32 [ 0, %.lr.ph ], [ %12, %middle.block ]
  br label %scalar.ph

scalar.ph:                                        ; preds = %scalar.ph.preheader, %scalar.ph
  %indvars.iv = phi i64 [ %indvars.iv.next, %scalar.ph ], [ %indvars.iv.ph, %scalar.ph.preheader ]
  %.011 = phi i32 [ %19, %scalar.ph ], [ %.011.ph, %scalar.ph.preheader ]
  %13 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %14 = load i32, ptr %13, align 4, !tbaa !9
  %15 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %16 = load i32, ptr %15, align 4, !tbaa !9
  %17 = add nsw i32 %16, %14
  %18 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %17, ptr %18, align 4, !tbaa !9
  %19 = add i32 %17, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge.loopexit, label %scalar.ph, !llvm.loop !19

._crit_edge.loopexit:                             ; preds = %scalar.ph
  %.lcssa = phi i32 [ %19, %scalar.ph ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %middle.block, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %12, %middle.block ], [ %.lcssa, %._crit_edge.loopexit ]
  ret i32 %.0.lcssa
}
Running pass: InstCombinePass on sum_1 (48 instructions)
Invalidating analysis: ScalarEvolutionAnalysis on sum_1
; *** IR Dump After InstCombinePass on sum_1 ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  %min.iters.check = icmp ult i32 %1, 8
  br i1 %min.iters.check, label %scalar.ph.preheader, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %n.vec = and i64 %wide.trip.count, 2147483640
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %vec.phi = phi <8 x i32> [ zeroinitializer, %vector.ph ], [ %10, %vector.body ]
  %6 = getelementptr inbounds i32, ptr %3, i64 %index
  %wide.load = load <8 x i32>, ptr %6, align 4, !tbaa !9
  %7 = getelementptr inbounds i32, ptr %4, i64 %index
  %wide.load13 = load <8 x i32>, ptr %7, align 4, !tbaa !9
  %8 = add nsw <8 x i32> %wide.load13, %wide.load
  %9 = getelementptr inbounds i32, ptr %5, i64 %index
  store <8 x i32> %8, ptr %9, align 4, !tbaa !9
  %10 = add <8 x i32> %8, %vec.phi
  %index.next = add nuw i64 %index, 8
  %11 = icmp eq i64 %index.next, %n.vec
  br i1 %11, label %middle.block, label %vector.body, !llvm.loop !16

middle.block:                                     ; preds = %vector.body
  %12 = call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %10)
  %cmp.n = icmp eq i64 %n.vec, %wide.trip.count
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph.preheader

scalar.ph.preheader:                              ; preds = %middle.block, %.lr.ph
  %indvars.iv.ph = phi i64 [ 0, %.lr.ph ], [ %n.vec, %middle.block ]
  %.011.ph = phi i32 [ 0, %.lr.ph ], [ %12, %middle.block ]
  br label %scalar.ph

scalar.ph:                                        ; preds = %scalar.ph.preheader, %scalar.ph
  %indvars.iv = phi i64 [ %indvars.iv.next, %scalar.ph ], [ %indvars.iv.ph, %scalar.ph.preheader ]
  %.011 = phi i32 [ %19, %scalar.ph ], [ %.011.ph, %scalar.ph.preheader ]
  %13 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %14 = load i32, ptr %13, align 4, !tbaa !9
  %15 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %16 = load i32, ptr %15, align 4, !tbaa !9
  %17 = add nsw i32 %16, %14
  %18 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %17, ptr %18, align 4, !tbaa !9
  %19 = add i32 %17, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge.loopexit, label %scalar.ph, !llvm.loop !19

._crit_edge.loopexit:                             ; preds = %scalar.ph
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %middle.block, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %12, %middle.block ], [ %19, %._crit_edge.loopexit ]
  ret i32 %.0.lcssa
}
Running pass: LoopSimplifyPass on sum_1 (46 instructions)
; *** IR Dump After LoopSimplifyPass on sum_1 ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  %min.iters.check = icmp ult i32 %1, 8
  br i1 %min.iters.check, label %scalar.ph.preheader, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %n.vec = and i64 %wide.trip.count, 2147483640
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %vec.phi = phi <8 x i32> [ zeroinitializer, %vector.ph ], [ %10, %vector.body ]
  %6 = getelementptr inbounds i32, ptr %3, i64 %index
  %wide.load = load <8 x i32>, ptr %6, align 4, !tbaa !9
  %7 = getelementptr inbounds i32, ptr %4, i64 %index
  %wide.load13 = load <8 x i32>, ptr %7, align 4, !tbaa !9
  %8 = add nsw <8 x i32> %wide.load13, %wide.load
  %9 = getelementptr inbounds i32, ptr %5, i64 %index
  store <8 x i32> %8, ptr %9, align 4, !tbaa !9
  %10 = add <8 x i32> %8, %vec.phi
  %index.next = add nuw i64 %index, 8
  %11 = icmp eq i64 %index.next, %n.vec
  br i1 %11, label %middle.block, label %vector.body, !llvm.loop !16

middle.block:                                     ; preds = %vector.body
  %12 = call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %10)
  %cmp.n = icmp eq i64 %n.vec, %wide.trip.count
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph.preheader

scalar.ph.preheader:                              ; preds = %middle.block, %.lr.ph
  %indvars.iv.ph = phi i64 [ 0, %.lr.ph ], [ %n.vec, %middle.block ]
  %.011.ph = phi i32 [ 0, %.lr.ph ], [ %12, %middle.block ]
  br label %scalar.ph

scalar.ph:                                        ; preds = %scalar.ph.preheader, %scalar.ph
  %indvars.iv = phi i64 [ %indvars.iv.next, %scalar.ph ], [ %indvars.iv.ph, %scalar.ph.preheader ]
  %.011 = phi i32 [ %19, %scalar.ph ], [ %.011.ph, %scalar.ph.preheader ]
  %13 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %14 = load i32, ptr %13, align 4, !tbaa !9
  %15 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %16 = load i32, ptr %15, align 4, !tbaa !9
  %17 = add nsw i32 %16, %14
  %18 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %17, ptr %18, align 4, !tbaa !9
  %19 = add i32 %17, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge.loopexit, label %scalar.ph, !llvm.loop !19

._crit_edge.loopexit:                             ; preds = %scalar.ph
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %middle.block, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %12, %middle.block ], [ %19, %._crit_edge.loopexit ]
  ret i32 %.0.lcssa
}
Running pass: LCSSAPass on sum_1 (46 instructions)
; *** IR Dump After LCSSAPass on sum_1 ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  %min.iters.check = icmp ult i32 %1, 8
  br i1 %min.iters.check, label %scalar.ph.preheader, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %n.vec = and i64 %wide.trip.count, 2147483640
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %vec.phi = phi <8 x i32> [ zeroinitializer, %vector.ph ], [ %10, %vector.body ]
  %6 = getelementptr inbounds i32, ptr %3, i64 %index
  %wide.load = load <8 x i32>, ptr %6, align 4, !tbaa !9
  %7 = getelementptr inbounds i32, ptr %4, i64 %index
  %wide.load13 = load <8 x i32>, ptr %7, align 4, !tbaa !9
  %8 = add nsw <8 x i32> %wide.load13, %wide.load
  %9 = getelementptr inbounds i32, ptr %5, i64 %index
  store <8 x i32> %8, ptr %9, align 4, !tbaa !9
  %10 = add <8 x i32> %8, %vec.phi
  %index.next = add nuw i64 %index, 8
  %11 = icmp eq i64 %index.next, %n.vec
  br i1 %11, label %middle.block, label %vector.body, !llvm.loop !16

middle.block:                                     ; preds = %vector.body
  %.lcssa15 = phi <8 x i32> [ %10, %vector.body ]
  %12 = call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %.lcssa15)
  %cmp.n = icmp eq i64 %n.vec, %wide.trip.count
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph.preheader

scalar.ph.preheader:                              ; preds = %middle.block, %.lr.ph
  %indvars.iv.ph = phi i64 [ 0, %.lr.ph ], [ %n.vec, %middle.block ]
  %.011.ph = phi i32 [ 0, %.lr.ph ], [ %12, %middle.block ]
  br label %scalar.ph

scalar.ph:                                        ; preds = %scalar.ph.preheader, %scalar.ph
  %indvars.iv = phi i64 [ %indvars.iv.next, %scalar.ph ], [ %indvars.iv.ph, %scalar.ph.preheader ]
  %.011 = phi i32 [ %19, %scalar.ph ], [ %.011.ph, %scalar.ph.preheader ]
  %13 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %14 = load i32, ptr %13, align 4, !tbaa !9
  %15 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %16 = load i32, ptr %15, align 4, !tbaa !9
  %17 = add nsw i32 %16, %14
  %18 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %17, ptr %18, align 4, !tbaa !9
  %19 = add i32 %17, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge.loopexit, label %scalar.ph, !llvm.loop !19

._crit_edge.loopexit:                             ; preds = %scalar.ph
  %.lcssa = phi i32 [ %19, %scalar.ph ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %middle.block, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %12, %middle.block ], [ %.lcssa, %._crit_edge.loopexit ]
  ret i32 %.0.lcssa
}
Running analysis: MemorySSAAnalysis on sum_1
Running analysis: ScalarEvolutionAnalysis on sum_1
Running analysis: InnerAnalysisManagerProxy<AnalysisManager<Loop, LoopStandardAnalysisResults&>, Function> on sum_1
Running pass: LICMPass on loop %vector.body in function sum_1
; *** IR Dump After LICMPass on loop %vector.body in function sum_1 ***

; Preheader:
vector.ph:                                        ; preds = %.lr.ph
  %n.vec = and i64 %wide.trip.count, 2147483640
  br label %vector.body

; Loop:
vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %vec.phi = phi <8 x i32> [ zeroinitializer, %vector.ph ], [ %10, %vector.body ]
  %6 = getelementptr inbounds i32, ptr %3, i64 %index
  %wide.load = load <8 x i32>, ptr %6, align 4, !tbaa !5
  %7 = getelementptr inbounds i32, ptr %4, i64 %index
  %wide.load13 = load <8 x i32>, ptr %7, align 4, !tbaa !5
  %8 = add nsw <8 x i32> %wide.load13, %wide.load
  %9 = getelementptr inbounds i32, ptr %5, i64 %index
  store <8 x i32> %8, ptr %9, align 4, !tbaa !5
  %10 = add <8 x i32> %8, %vec.phi
  %index.next = add nuw i64 %index, 8
  %11 = icmp eq i64 %index.next, %n.vec
  br i1 %11, label %middle.block, label %vector.body, !llvm.loop !11

; Exit blocks
middle.block:                                     ; preds = %vector.body
  %.lcssa15 = phi <8 x i32> [ %10, %vector.body ]
  %12 = call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %.lcssa15)
  %cmp.n = icmp eq i64 %n.vec, %wide.trip.count
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph.preheader
Running pass: LICMPass on loop %scalar.ph in function sum_1
; *** IR Dump After LICMPass on loop %scalar.ph in function sum_1 ***

; Preheader:
scalar.ph.preheader:                              ; preds = %middle.block, %.lr.ph
  %indvars.iv.ph = phi i64 [ 0, %.lr.ph ], [ %n.vec, %middle.block ]
  %.011.ph = phi i32 [ 0, %.lr.ph ], [ %12, %middle.block ]
  br label %scalar.ph

; Loop:
scalar.ph:                                        ; preds = %scalar.ph.preheader, %scalar.ph
  %indvars.iv = phi i64 [ %indvars.iv.next, %scalar.ph ], [ %indvars.iv.ph, %scalar.ph.preheader ]
  %.011 = phi i32 [ %19, %scalar.ph ], [ %.011.ph, %scalar.ph.preheader ]
  %13 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %14 = load i32, ptr %13, align 4, !tbaa !5
  %15 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %16 = load i32, ptr %15, align 4, !tbaa !5
  %17 = add nsw i32 %16, %14
  %18 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %17, ptr %18, align 4, !tbaa !5
  %19 = add i32 %17, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge.loopexit, label %scalar.ph, !llvm.loop !16

; Exit blocks
._crit_edge.loopexit:                             ; preds = %scalar.ph
  %.lcssa = phi i32 [ %19, %scalar.ph ]
  br label %._crit_edge
Running pass: AlignmentFromAssumptionsPass on sum_1 (48 instructions)
; *** IR Dump After AlignmentFromAssumptionsPass on sum_1 ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  %min.iters.check = icmp ult i32 %1, 8
  br i1 %min.iters.check, label %scalar.ph.preheader, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %n.vec = and i64 %wide.trip.count, 2147483640
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %vec.phi = phi <8 x i32> [ zeroinitializer, %vector.ph ], [ %10, %vector.body ]
  %6 = getelementptr inbounds i32, ptr %3, i64 %index
  %wide.load = load <8 x i32>, ptr %6, align 4, !tbaa !9
  %7 = getelementptr inbounds i32, ptr %4, i64 %index
  %wide.load13 = load <8 x i32>, ptr %7, align 4, !tbaa !9
  %8 = add nsw <8 x i32> %wide.load13, %wide.load
  %9 = getelementptr inbounds i32, ptr %5, i64 %index
  store <8 x i32> %8, ptr %9, align 4, !tbaa !9
  %10 = add <8 x i32> %8, %vec.phi
  %index.next = add nuw i64 %index, 8
  %11 = icmp eq i64 %index.next, %n.vec
  br i1 %11, label %middle.block, label %vector.body, !llvm.loop !16

middle.block:                                     ; preds = %vector.body
  %.lcssa15 = phi <8 x i32> [ %10, %vector.body ]
  %12 = call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %.lcssa15)
  %cmp.n = icmp eq i64 %n.vec, %wide.trip.count
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph.preheader

scalar.ph.preheader:                              ; preds = %middle.block, %.lr.ph
  %indvars.iv.ph = phi i64 [ 0, %.lr.ph ], [ %n.vec, %middle.block ]
  %.011.ph = phi i32 [ 0, %.lr.ph ], [ %12, %middle.block ]
  br label %scalar.ph

scalar.ph:                                        ; preds = %scalar.ph.preheader, %scalar.ph
  %indvars.iv = phi i64 [ %indvars.iv.next, %scalar.ph ], [ %indvars.iv.ph, %scalar.ph.preheader ]
  %.011 = phi i32 [ %19, %scalar.ph ], [ %.011.ph, %scalar.ph.preheader ]
  %13 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %14 = load i32, ptr %13, align 4, !tbaa !9
  %15 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %16 = load i32, ptr %15, align 4, !tbaa !9
  %17 = add nsw i32 %16, %14
  %18 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %17, ptr %18, align 4, !tbaa !9
  %19 = add i32 %17, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge.loopexit, label %scalar.ph, !llvm.loop !19

._crit_edge.loopexit:                             ; preds = %scalar.ph
  %.lcssa = phi i32 [ %19, %scalar.ph ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %middle.block, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %12, %middle.block ], [ %.lcssa, %._crit_edge.loopexit ]
  ret i32 %.0.lcssa
}
Running pass: LoopSinkPass on sum_1 (48 instructions)
; *** IR Dump After LoopSinkPass on sum_1 ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  %min.iters.check = icmp ult i32 %1, 8
  br i1 %min.iters.check, label %scalar.ph.preheader, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %n.vec = and i64 %wide.trip.count, 2147483640
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %vec.phi = phi <8 x i32> [ zeroinitializer, %vector.ph ], [ %10, %vector.body ]
  %6 = getelementptr inbounds i32, ptr %3, i64 %index
  %wide.load = load <8 x i32>, ptr %6, align 4, !tbaa !9
  %7 = getelementptr inbounds i32, ptr %4, i64 %index
  %wide.load13 = load <8 x i32>, ptr %7, align 4, !tbaa !9
  %8 = add nsw <8 x i32> %wide.load13, %wide.load
  %9 = getelementptr inbounds i32, ptr %5, i64 %index
  store <8 x i32> %8, ptr %9, align 4, !tbaa !9
  %10 = add <8 x i32> %8, %vec.phi
  %index.next = add nuw i64 %index, 8
  %11 = icmp eq i64 %index.next, %n.vec
  br i1 %11, label %middle.block, label %vector.body, !llvm.loop !16

middle.block:                                     ; preds = %vector.body
  %.lcssa15 = phi <8 x i32> [ %10, %vector.body ]
  %12 = call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %.lcssa15)
  %cmp.n = icmp eq i64 %n.vec, %wide.trip.count
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph.preheader

scalar.ph.preheader:                              ; preds = %middle.block, %.lr.ph
  %indvars.iv.ph = phi i64 [ 0, %.lr.ph ], [ %n.vec, %middle.block ]
  %.011.ph = phi i32 [ 0, %.lr.ph ], [ %12, %middle.block ]
  br label %scalar.ph

scalar.ph:                                        ; preds = %scalar.ph.preheader, %scalar.ph
  %indvars.iv = phi i64 [ %indvars.iv.next, %scalar.ph ], [ %indvars.iv.ph, %scalar.ph.preheader ]
  %.011 = phi i32 [ %19, %scalar.ph ], [ %.011.ph, %scalar.ph.preheader ]
  %13 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %14 = load i32, ptr %13, align 4, !tbaa !9
  %15 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %16 = load i32, ptr %15, align 4, !tbaa !9
  %17 = add nsw i32 %16, %14
  %18 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %17, ptr %18, align 4, !tbaa !9
  %19 = add i32 %17, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge.loopexit, label %scalar.ph, !llvm.loop !19

._crit_edge.loopexit:                             ; preds = %scalar.ph
  %.lcssa = phi i32 [ %19, %scalar.ph ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %middle.block, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %12, %middle.block ], [ %.lcssa, %._crit_edge.loopexit ]
  ret i32 %.0.lcssa
}
Running pass: InstSimplifyPass on sum_1 (48 instructions)
Invalidating analysis: MemorySSAAnalysis on sum_1
Invalidating analysis: ScalarEvolutionAnalysis on sum_1
Invalidating analysis: InnerAnalysisManagerProxy<AnalysisManager<Loop, LoopStandardAnalysisResults&>, Function> on sum_1
; *** IR Dump After InstSimplifyPass on sum_1 ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  %min.iters.check = icmp ult i32 %1, 8
  br i1 %min.iters.check, label %scalar.ph.preheader, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %n.vec = and i64 %wide.trip.count, 2147483640
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %vec.phi = phi <8 x i32> [ zeroinitializer, %vector.ph ], [ %10, %vector.body ]
  %6 = getelementptr inbounds i32, ptr %3, i64 %index
  %wide.load = load <8 x i32>, ptr %6, align 4, !tbaa !9
  %7 = getelementptr inbounds i32, ptr %4, i64 %index
  %wide.load13 = load <8 x i32>, ptr %7, align 4, !tbaa !9
  %8 = add nsw <8 x i32> %wide.load13, %wide.load
  %9 = getelementptr inbounds i32, ptr %5, i64 %index
  store <8 x i32> %8, ptr %9, align 4, !tbaa !9
  %10 = add <8 x i32> %8, %vec.phi
  %index.next = add nuw i64 %index, 8
  %11 = icmp eq i64 %index.next, %n.vec
  br i1 %11, label %middle.block, label %vector.body, !llvm.loop !16

middle.block:                                     ; preds = %vector.body
  %12 = call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %10)
  %cmp.n = icmp eq i64 %n.vec, %wide.trip.count
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph.preheader

scalar.ph.preheader:                              ; preds = %middle.block, %.lr.ph
  %indvars.iv.ph = phi i64 [ 0, %.lr.ph ], [ %n.vec, %middle.block ]
  %.011.ph = phi i32 [ 0, %.lr.ph ], [ %12, %middle.block ]
  br label %scalar.ph

scalar.ph:                                        ; preds = %scalar.ph.preheader, %scalar.ph
  %indvars.iv = phi i64 [ %indvars.iv.next, %scalar.ph ], [ %indvars.iv.ph, %scalar.ph.preheader ]
  %.011 = phi i32 [ %19, %scalar.ph ], [ %.011.ph, %scalar.ph.preheader ]
  %13 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %14 = load i32, ptr %13, align 4, !tbaa !9
  %15 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %16 = load i32, ptr %15, align 4, !tbaa !9
  %17 = add nsw i32 %16, %14
  %18 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %17, ptr %18, align 4, !tbaa !9
  %19 = add i32 %17, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge.loopexit, label %scalar.ph, !llvm.loop !19

._crit_edge.loopexit:                             ; preds = %scalar.ph
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %middle.block, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %12, %middle.block ], [ %19, %._crit_edge.loopexit ]
  ret i32 %.0.lcssa
}
Running pass: DivRemPairsPass on sum_1 (46 instructions)
; *** IR Dump After DivRemPairsPass on sum_1 ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  %min.iters.check = icmp ult i32 %1, 8
  br i1 %min.iters.check, label %scalar.ph.preheader, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %n.vec = and i64 %wide.trip.count, 2147483640
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %vec.phi = phi <8 x i32> [ zeroinitializer, %vector.ph ], [ %10, %vector.body ]
  %6 = getelementptr inbounds i32, ptr %3, i64 %index
  %wide.load = load <8 x i32>, ptr %6, align 4, !tbaa !9
  %7 = getelementptr inbounds i32, ptr %4, i64 %index
  %wide.load13 = load <8 x i32>, ptr %7, align 4, !tbaa !9
  %8 = add nsw <8 x i32> %wide.load13, %wide.load
  %9 = getelementptr inbounds i32, ptr %5, i64 %index
  store <8 x i32> %8, ptr %9, align 4, !tbaa !9
  %10 = add <8 x i32> %8, %vec.phi
  %index.next = add nuw i64 %index, 8
  %11 = icmp eq i64 %index.next, %n.vec
  br i1 %11, label %middle.block, label %vector.body, !llvm.loop !16

middle.block:                                     ; preds = %vector.body
  %12 = call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %10)
  %cmp.n = icmp eq i64 %n.vec, %wide.trip.count
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph.preheader

scalar.ph.preheader:                              ; preds = %middle.block, %.lr.ph
  %indvars.iv.ph = phi i64 [ 0, %.lr.ph ], [ %n.vec, %middle.block ]
  %.011.ph = phi i32 [ 0, %.lr.ph ], [ %12, %middle.block ]
  br label %scalar.ph

scalar.ph:                                        ; preds = %scalar.ph.preheader, %scalar.ph
  %indvars.iv = phi i64 [ %indvars.iv.next, %scalar.ph ], [ %indvars.iv.ph, %scalar.ph.preheader ]
  %.011 = phi i32 [ %19, %scalar.ph ], [ %.011.ph, %scalar.ph.preheader ]
  %13 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %14 = load i32, ptr %13, align 4, !tbaa !9
  %15 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %16 = load i32, ptr %15, align 4, !tbaa !9
  %17 = add nsw i32 %16, %14
  %18 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %17, ptr %18, align 4, !tbaa !9
  %19 = add i32 %17, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge.loopexit, label %scalar.ph, !llvm.loop !19

._crit_edge.loopexit:                             ; preds = %scalar.ph
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %middle.block, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %12, %middle.block ], [ %19, %._crit_edge.loopexit ]
  ret i32 %.0.lcssa
}
Running pass: TailCallElimPass on sum_1 (46 instructions)
Invalidating analysis: LoopAnalysis on sum_1
; *** IR Dump After TailCallElimPass on sum_1 ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  %min.iters.check = icmp ult i32 %1, 8
  br i1 %min.iters.check, label %scalar.ph.preheader, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %n.vec = and i64 %wide.trip.count, 2147483640
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %vec.phi = phi <8 x i32> [ zeroinitializer, %vector.ph ], [ %10, %vector.body ]
  %6 = getelementptr inbounds i32, ptr %3, i64 %index
  %wide.load = load <8 x i32>, ptr %6, align 4, !tbaa !9
  %7 = getelementptr inbounds i32, ptr %4, i64 %index
  %wide.load13 = load <8 x i32>, ptr %7, align 4, !tbaa !9
  %8 = add nsw <8 x i32> %wide.load13, %wide.load
  %9 = getelementptr inbounds i32, ptr %5, i64 %index
  store <8 x i32> %8, ptr %9, align 4, !tbaa !9
  %10 = add <8 x i32> %8, %vec.phi
  %index.next = add nuw i64 %index, 8
  %11 = icmp eq i64 %index.next, %n.vec
  br i1 %11, label %middle.block, label %vector.body, !llvm.loop !16

middle.block:                                     ; preds = %vector.body
  %12 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %10)
  %cmp.n = icmp eq i64 %n.vec, %wide.trip.count
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph.preheader

scalar.ph.preheader:                              ; preds = %middle.block, %.lr.ph
  %indvars.iv.ph = phi i64 [ 0, %.lr.ph ], [ %n.vec, %middle.block ]
  %.011.ph = phi i32 [ 0, %.lr.ph ], [ %12, %middle.block ]
  br label %scalar.ph

scalar.ph:                                        ; preds = %scalar.ph.preheader, %scalar.ph
  %indvars.iv = phi i64 [ %indvars.iv.next, %scalar.ph ], [ %indvars.iv.ph, %scalar.ph.preheader ]
  %.011 = phi i32 [ %19, %scalar.ph ], [ %.011.ph, %scalar.ph.preheader ]
  %13 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %14 = load i32, ptr %13, align 4, !tbaa !9
  %15 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %16 = load i32, ptr %15, align 4, !tbaa !9
  %17 = add nsw i32 %16, %14
  %18 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %17, ptr %18, align 4, !tbaa !9
  %19 = add i32 %17, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge.loopexit, label %scalar.ph, !llvm.loop !19

._crit_edge.loopexit:                             ; preds = %scalar.ph
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %middle.block, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %12, %middle.block ], [ %19, %._crit_edge.loopexit ]
  ret i32 %.0.lcssa
}
Running pass: SimplifyCFGPass on sum_1 (46 instructions)
Invalidating analysis: DominatorTreeAnalysis on sum_1
Invalidating analysis: BasicAA on sum_1
Invalidating analysis: AAManager on sum_1
; *** IR Dump After SimplifyCFGPass on sum_1 ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  %min.iters.check = icmp ult i32 %1, 8
  br i1 %min.iters.check, label %scalar.ph.preheader, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %n.vec = and i64 %wide.trip.count, 2147483640
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %vec.phi = phi <8 x i32> [ zeroinitializer, %vector.ph ], [ %10, %vector.body ]
  %6 = getelementptr inbounds i32, ptr %3, i64 %index
  %wide.load = load <8 x i32>, ptr %6, align 4, !tbaa !9
  %7 = getelementptr inbounds i32, ptr %4, i64 %index
  %wide.load13 = load <8 x i32>, ptr %7, align 4, !tbaa !9
  %8 = add nsw <8 x i32> %wide.load13, %wide.load
  %9 = getelementptr inbounds i32, ptr %5, i64 %index
  store <8 x i32> %8, ptr %9, align 4, !tbaa !9
  %10 = add <8 x i32> %8, %vec.phi
  %index.next = add nuw i64 %index, 8
  %11 = icmp eq i64 %index.next, %n.vec
  br i1 %11, label %middle.block, label %vector.body, !llvm.loop !16

middle.block:                                     ; preds = %vector.body
  %12 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %10)
  %cmp.n = icmp eq i64 %n.vec, %wide.trip.count
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph.preheader

scalar.ph.preheader:                              ; preds = %middle.block, %.lr.ph
  %indvars.iv.ph = phi i64 [ 0, %.lr.ph ], [ %n.vec, %middle.block ]
  %.011.ph = phi i32 [ 0, %.lr.ph ], [ %12, %middle.block ]
  br label %scalar.ph

scalar.ph:                                        ; preds = %scalar.ph.preheader, %scalar.ph
  %indvars.iv = phi i64 [ %indvars.iv.next, %scalar.ph ], [ %indvars.iv.ph, %scalar.ph.preheader ]
  %.011 = phi i32 [ %19, %scalar.ph ], [ %.011.ph, %scalar.ph.preheader ]
  %13 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %14 = load i32, ptr %13, align 4, !tbaa !9
  %15 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %16 = load i32, ptr %15, align 4, !tbaa !9
  %17 = add nsw i32 %16, %14
  %18 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %17, ptr %18, align 4, !tbaa !9
  %19 = add i32 %17, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge, label %scalar.ph, !llvm.loop !19

._crit_edge:                                      ; preds = %scalar.ph, %middle.block, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %12, %middle.block ], [ %19, %scalar.ph ]
  ret i32 %.0.lcssa
}
Invalidating analysis: LazyCallGraphAnalysis on [module]
Invalidating analysis: InnerAnalysisManagerProxy<AnalysisManager<LazyCallGraph::SCC, LazyCallGraph&>, Module> on [module]
Invalidating analysis: CallGraphAnalysis on [module]
Running pass: GlobalDCEPass on [module]
; *** IR Dump After GlobalDCEPass on [module] ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  %min.iters.check = icmp ult i32 %1, 8
  br i1 %min.iters.check, label %scalar.ph.preheader, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %n.vec = and i64 %wide.trip.count, 2147483640
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %vec.phi = phi <8 x i32> [ zeroinitializer, %vector.ph ], [ %10, %vector.body ]
  %6 = getelementptr inbounds i32, ptr %3, i64 %index
  %wide.load = load <8 x i32>, ptr %6, align 4, !tbaa !9
  %7 = getelementptr inbounds i32, ptr %4, i64 %index
  %wide.load13 = load <8 x i32>, ptr %7, align 4, !tbaa !9
  %8 = add nsw <8 x i32> %wide.load13, %wide.load
  %9 = getelementptr inbounds i32, ptr %5, i64 %index
  store <8 x i32> %8, ptr %9, align 4, !tbaa !9
  %10 = add <8 x i32> %8, %vec.phi
  %index.next = add nuw i64 %index, 8
  %11 = icmp eq i64 %index.next, %n.vec
  br i1 %11, label %middle.block, label %vector.body, !llvm.loop !16

middle.block:                                     ; preds = %vector.body
  %12 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %10)
  %cmp.n = icmp eq i64 %n.vec, %wide.trip.count
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph.preheader

scalar.ph.preheader:                              ; preds = %middle.block, %.lr.ph
  %indvars.iv.ph = phi i64 [ 0, %.lr.ph ], [ %n.vec, %middle.block ]
  %.011.ph = phi i32 [ 0, %.lr.ph ], [ %12, %middle.block ]
  br label %scalar.ph

scalar.ph:                                        ; preds = %scalar.ph.preheader, %scalar.ph
  %indvars.iv = phi i64 [ %indvars.iv.next, %scalar.ph ], [ %indvars.iv.ph, %scalar.ph.preheader ]
  %.011 = phi i32 [ %19, %scalar.ph ], [ %.011.ph, %scalar.ph.preheader ]
  %13 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %14 = load i32, ptr %13, align 4, !tbaa !9
  %15 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %16 = load i32, ptr %15, align 4, !tbaa !9
  %17 = add nsw i32 %16, %14
  %18 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %17, ptr %18, align 4, !tbaa !9
  %19 = add i32 %17, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge, label %scalar.ph, !llvm.loop !19

._crit_edge:                                      ; preds = %scalar.ph, %middle.block, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %12, %middle.block ], [ %19, %scalar.ph ]
  ret i32 %.0.lcssa
}
Running pass: ConstantMergePass on [module]
; *** IR Dump After ConstantMergePass on [module] ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  %min.iters.check = icmp ult i32 %1, 8
  br i1 %min.iters.check, label %scalar.ph.preheader, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %n.vec = and i64 %wide.trip.count, 2147483640
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %vec.phi = phi <8 x i32> [ zeroinitializer, %vector.ph ], [ %10, %vector.body ]
  %6 = getelementptr inbounds i32, ptr %3, i64 %index
  %wide.load = load <8 x i32>, ptr %6, align 4, !tbaa !9
  %7 = getelementptr inbounds i32, ptr %4, i64 %index
  %wide.load13 = load <8 x i32>, ptr %7, align 4, !tbaa !9
  %8 = add nsw <8 x i32> %wide.load13, %wide.load
  %9 = getelementptr inbounds i32, ptr %5, i64 %index
  store <8 x i32> %8, ptr %9, align 4, !tbaa !9
  %10 = add <8 x i32> %8, %vec.phi
  %index.next = add nuw i64 %index, 8
  %11 = icmp eq i64 %index.next, %n.vec
  br i1 %11, label %middle.block, label %vector.body, !llvm.loop !16

middle.block:                                     ; preds = %vector.body
  %12 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %10)
  %cmp.n = icmp eq i64 %n.vec, %wide.trip.count
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph.preheader

scalar.ph.preheader:                              ; preds = %middle.block, %.lr.ph
  %indvars.iv.ph = phi i64 [ 0, %.lr.ph ], [ %n.vec, %middle.block ]
  %.011.ph = phi i32 [ 0, %.lr.ph ], [ %12, %middle.block ]
  br label %scalar.ph

scalar.ph:                                        ; preds = %scalar.ph.preheader, %scalar.ph
  %indvars.iv = phi i64 [ %indvars.iv.next, %scalar.ph ], [ %indvars.iv.ph, %scalar.ph.preheader ]
  %.011 = phi i32 [ %19, %scalar.ph ], [ %.011.ph, %scalar.ph.preheader ]
  %13 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %14 = load i32, ptr %13, align 4, !tbaa !9
  %15 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %16 = load i32, ptr %15, align 4, !tbaa !9
  %17 = add nsw i32 %16, %14
  %18 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %17, ptr %18, align 4, !tbaa !9
  %19 = add i32 %17, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge, label %scalar.ph, !llvm.loop !19

._crit_edge:                                      ; preds = %scalar.ph, %middle.block, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %12, %middle.block ], [ %19, %scalar.ph ]
  ret i32 %.0.lcssa
}
Running pass: CGProfilePass on [module]
; *** IR Dump After CGProfilePass on [module] ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  %min.iters.check = icmp ult i32 %1, 8
  br i1 %min.iters.check, label %scalar.ph.preheader, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %n.vec = and i64 %wide.trip.count, 2147483640
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %vec.phi = phi <8 x i32> [ zeroinitializer, %vector.ph ], [ %10, %vector.body ]
  %6 = getelementptr inbounds i32, ptr %3, i64 %index
  %wide.load = load <8 x i32>, ptr %6, align 4, !tbaa !9
  %7 = getelementptr inbounds i32, ptr %4, i64 %index
  %wide.load13 = load <8 x i32>, ptr %7, align 4, !tbaa !9
  %8 = add nsw <8 x i32> %wide.load13, %wide.load
  %9 = getelementptr inbounds i32, ptr %5, i64 %index
  store <8 x i32> %8, ptr %9, align 4, !tbaa !9
  %10 = add <8 x i32> %8, %vec.phi
  %index.next = add nuw i64 %index, 8
  %11 = icmp eq i64 %index.next, %n.vec
  br i1 %11, label %middle.block, label %vector.body, !llvm.loop !16

middle.block:                                     ; preds = %vector.body
  %12 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %10)
  %cmp.n = icmp eq i64 %n.vec, %wide.trip.count
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph.preheader

scalar.ph.preheader:                              ; preds = %middle.block, %.lr.ph
  %indvars.iv.ph = phi i64 [ 0, %.lr.ph ], [ %n.vec, %middle.block ]
  %.011.ph = phi i32 [ 0, %.lr.ph ], [ %12, %middle.block ]
  br label %scalar.ph

scalar.ph:                                        ; preds = %scalar.ph.preheader, %scalar.ph
  %indvars.iv = phi i64 [ %indvars.iv.next, %scalar.ph ], [ %indvars.iv.ph, %scalar.ph.preheader ]
  %.011 = phi i32 [ %19, %scalar.ph ], [ %.011.ph, %scalar.ph.preheader ]
  %13 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %14 = load i32, ptr %13, align 4, !tbaa !9
  %15 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %16 = load i32, ptr %15, align 4, !tbaa !9
  %17 = add nsw i32 %16, %14
  %18 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %17, ptr %18, align 4, !tbaa !9
  %19 = add i32 %17, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge, label %scalar.ph, !llvm.loop !19

._crit_edge:                                      ; preds = %scalar.ph, %middle.block, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %12, %middle.block ], [ %19, %scalar.ph ]
  ret i32 %.0.lcssa
}
Running pass: RelLookupTableConverterPass on [module]
; *** IR Dump After RelLookupTableConverterPass on [module] ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  %min.iters.check = icmp ult i32 %1, 8
  br i1 %min.iters.check, label %scalar.ph.preheader, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %n.vec = and i64 %wide.trip.count, 2147483640
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %vec.phi = phi <8 x i32> [ zeroinitializer, %vector.ph ], [ %10, %vector.body ]
  %6 = getelementptr inbounds i32, ptr %3, i64 %index
  %wide.load = load <8 x i32>, ptr %6, align 4, !tbaa !9
  %7 = getelementptr inbounds i32, ptr %4, i64 %index
  %wide.load13 = load <8 x i32>, ptr %7, align 4, !tbaa !9
  %8 = add nsw <8 x i32> %wide.load13, %wide.load
  %9 = getelementptr inbounds i32, ptr %5, i64 %index
  store <8 x i32> %8, ptr %9, align 4, !tbaa !9
  %10 = add <8 x i32> %8, %vec.phi
  %index.next = add nuw i64 %index, 8
  %11 = icmp eq i64 %index.next, %n.vec
  br i1 %11, label %middle.block, label %vector.body, !llvm.loop !16

middle.block:                                     ; preds = %vector.body
  %12 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %10)
  %cmp.n = icmp eq i64 %n.vec, %wide.trip.count
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph.preheader

scalar.ph.preheader:                              ; preds = %middle.block, %.lr.ph
  %indvars.iv.ph = phi i64 [ 0, %.lr.ph ], [ %n.vec, %middle.block ]
  %.011.ph = phi i32 [ 0, %.lr.ph ], [ %12, %middle.block ]
  br label %scalar.ph

scalar.ph:                                        ; preds = %scalar.ph.preheader, %scalar.ph
  %indvars.iv = phi i64 [ %indvars.iv.next, %scalar.ph ], [ %indvars.iv.ph, %scalar.ph.preheader ]
  %.011 = phi i32 [ %19, %scalar.ph ], [ %.011.ph, %scalar.ph.preheader ]
  %13 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %14 = load i32, ptr %13, align 4, !tbaa !9
  %15 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %16 = load i32, ptr %15, align 4, !tbaa !9
  %17 = add nsw i32 %16, %14
  %18 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %17, ptr %18, align 4, !tbaa !9
  %19 = add i32 %17, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge, label %scalar.ph, !llvm.loop !19

._crit_edge:                                      ; preds = %scalar.ph, %middle.block, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %12, %middle.block ], [ %19, %scalar.ph ]
  ret i32 %.0.lcssa
}
Running pass: AnnotationRemarksPass on Initrand (2 instructions)
Running pass: AnnotationRemarksPass on Rand (7 instructions)
Running pass: AnnotationRemarksPass on InitArray (24 instructions)
Running pass: AnnotationRemarksPass on init (56 instructions)
Running pass: AnnotationRemarksPass on deinit (7 instructions)
Running pass: AnnotationRemarksPass on sum_1 (45 instructions)
; *** IR Dump After AnnotationRemarksPass on sum_1 ***
; Function Attrs: nofree norecurse nosync nounwind memory(readwrite, inaccessiblemem: none) uwtable
define dso_local i32 @sum_1() local_unnamed_addr #7 {
  %1 = load i32, ptr @size, align 4, !tbaa !9
  %2 = icmp sgt i32 %1, 0
  br i1 %2, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %3 = load ptr, ptr @ima, align 8, !tbaa !14
  %4 = load ptr, ptr @imb, align 8, !tbaa !14
  %5 = load ptr, ptr @imr, align 8, !tbaa !14
  %wide.trip.count = zext nneg i32 %1 to i64
  %min.iters.check = icmp ult i32 %1, 8
  br i1 %min.iters.check, label %scalar.ph.preheader, label %vector.ph

vector.ph:                                        ; preds = %.lr.ph
  %n.vec = and i64 %wide.trip.count, 2147483640
  br label %vector.body

vector.body:                                      ; preds = %vector.body, %vector.ph
  %index = phi i64 [ 0, %vector.ph ], [ %index.next, %vector.body ]
  %vec.phi = phi <8 x i32> [ zeroinitializer, %vector.ph ], [ %10, %vector.body ]
  %6 = getelementptr inbounds i32, ptr %3, i64 %index
  %wide.load = load <8 x i32>, ptr %6, align 4, !tbaa !9
  %7 = getelementptr inbounds i32, ptr %4, i64 %index
  %wide.load13 = load <8 x i32>, ptr %7, align 4, !tbaa !9
  %8 = add nsw <8 x i32> %wide.load13, %wide.load
  %9 = getelementptr inbounds i32, ptr %5, i64 %index
  store <8 x i32> %8, ptr %9, align 4, !tbaa !9
  %10 = add <8 x i32> %8, %vec.phi
  %index.next = add nuw i64 %index, 8
  %11 = icmp eq i64 %index.next, %n.vec
  br i1 %11, label %middle.block, label %vector.body, !llvm.loop !16

middle.block:                                     ; preds = %vector.body
  %12 = tail call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> %10)
  %cmp.n = icmp eq i64 %n.vec, %wide.trip.count
  br i1 %cmp.n, label %._crit_edge, label %scalar.ph.preheader

scalar.ph.preheader:                              ; preds = %middle.block, %.lr.ph
  %indvars.iv.ph = phi i64 [ 0, %.lr.ph ], [ %n.vec, %middle.block ]
  %.011.ph = phi i32 [ 0, %.lr.ph ], [ %12, %middle.block ]
  br label %scalar.ph

scalar.ph:                                        ; preds = %scalar.ph.preheader, %scalar.ph
  %indvars.iv = phi i64 [ %indvars.iv.next, %scalar.ph ], [ %indvars.iv.ph, %scalar.ph.preheader ]
  %.011 = phi i32 [ %19, %scalar.ph ], [ %.011.ph, %scalar.ph.preheader ]
  %13 = getelementptr inbounds i32, ptr %3, i64 %indvars.iv
  %14 = load i32, ptr %13, align 4, !tbaa !9
  %15 = getelementptr inbounds i32, ptr %4, i64 %indvars.iv
  %16 = load i32, ptr %15, align 4, !tbaa !9
  %17 = add nsw i32 %16, %14
  %18 = getelementptr inbounds i32, ptr %5, i64 %indvars.iv
  store i32 %17, ptr %18, align 4, !tbaa !9
  %19 = add i32 %17, %.011
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, %wide.trip.count
  br i1 %exitcond.not, label %._crit_edge, label %scalar.ph, !llvm.loop !19

._crit_edge:                                      ; preds = %scalar.ph, %middle.block, %0
  %.0.lcssa = phi i32 [ 0, %0 ], [ %12, %middle.block ], [ %19, %scalar.ph ]
  ret i32 %.0.lcssa
}
Running pass: VerifierPass on [module]
Running analysis: VerifierAnalysis on [module]
